{"pages":[{"tags":"Machine learning","title":"Implement multilayer perceptron for digit recognition","text":"This post will demonstrate how to implement multilayer perceptron for digit recognition. The detailed derivations of algorithm can be found from my script . Main workflow Preparing training/validation/testing datasets. Set the weight decay / numerical parameters. Check if the gradients of the loss function are correct. Training model. Estimate the accuracy of prediction. Ipython notebook In [1]: % load_ext autoreload % autoreload 2 % matplotlib inline import numpy as np import matplotlib.pyplot as plt from dnn_play.classifiers.mlp import MLP , mlp_loss , rel_err_gradients from dnn_play.utils.data_utils import load_mnist from dnn_play.utils.visualize_utils import display_network # Plot settings plt . rcParams [ 'figure.figsize' ] = ( 10.0 , 10.0 ) # set default size of plots plt . rcParams [ 'image.interpolation' ] = 'nearest' In [2]: # Load MNIST data ( X_train , y_train ), ( X_val , y_val ), ( X_test , y_test ) = load_mnist () #(X_train, y_train), (X_val, y_val), (X_test, y_test) = load_mnist(n_train=9000, n_val=1000, n_test=1000) print ( \"X_train shape = {} y_train shape = {}\" . format ( X_train . shape , y_train . shape )) print ( \"X_val shape = {} y_val shape = {}\" . format ( X_val . shape , y_val . shape )) print ( \"X_test shape = {} y_test shape = {}\" . format ( X_test . shape , y_test . shape )) X_train shape = (784, 55000) y_train shape = (55000,) X_val shape = (784, 5000) y_val shape = (5000,) X_test shape = (784, 10000) y_test shape = (10000,) In [3]: # Number of layer units input_size = X_train . shape [ 0 ] # Dimension of features hidden_size_L1 = 200 hidden_size_L2 = 200 output_size = np . max ( y_train ) + 1 # Number of classes # Network configuration #layer_units = ((input_size, output_size)) layer_units = (( input_size , hidden_size_L1 , output_size )) #layer_units = ((input_size, hidden_size_L1, hidden_size_L2, output_size)) # Hyperparameters reg = 1 e - 4 # Regulation, weight decay # Numerical parameters max_iters = 400 # Define the classifier clf = MLP ( layer_units ) # Initialize weights weights = clf . init_weights () loss , grad = mlp_loss ( weights , X_train , y_train , 0.0 ) # Note there are 10 classes. # As a rough sanity check, our loss should be something close to -log(0.1). print ( 'loss: %f' % loss ) print ( 'sanity check: %f' % ( - np . log ( 0.1 ))) loss: 2.302606 sanity check: 2.302585 In [4]: # Gradient checking if rel_err_gradients () < 1 e - 8 : print ( \"Gradient check passed!\" ) else : print ( \"Gradient check failed!\" ) Gradient check passed! In [5]: \"\"\" Training \"\"\" reg = 1 e - 4 # Regulation, weight decay #clf = MLP(layer_units, weights = weights) weights , loss_history , train_acc_history , val_acc_history = clf . fit ( X_train , y_train , X_val , y_val , reg = reg , max_iters = max_iters , verbose = True ) iter: 20, loss: 1.492642, train_acc: 0.469182, val_acc: 0.486800 iter: 40, loss: 0.374339, train_acc: 0.899927, val_acc: 0.917000 iter: 60, loss: 0.228775, train_acc: 0.943600, val_acc: 0.955400 iter: 80, loss: 0.164778, train_acc: 0.967891, val_acc: 0.974200 iter: 100, loss: 0.136664, train_acc: 0.980036, val_acc: 0.978600 iter: 120, loss: 0.119424, train_acc: 0.987036, val_acc: 0.980200 iter: 140, loss: 0.111179, train_acc: 0.990855, val_acc: 0.982000 iter: 160, loss: 0.106608, train_acc: 0.993455, val_acc: 0.982800 iter: 180, loss: 0.103801, train_acc: 0.994945, val_acc: 0.984400 iter: 200, loss: 0.101420, train_acc: 0.995164, val_acc: 0.984800 iter: 220, loss: 0.099555, train_acc: 0.995200, val_acc: 0.984800 iter: 240, loss: 0.098186, train_acc: 0.995655, val_acc: 0.986000 iter: 260, loss: 0.097174, train_acc: 0.995818, val_acc: 0.985400 iter: 280, loss: 0.096363, train_acc: 0.996073, val_acc: 0.985600 iter: 300, loss: 0.095713, train_acc: 0.996291, val_acc: 0.985600 iter: 320, loss: 0.095071, train_acc: 0.996036, val_acc: 0.985800 iter: 340, loss: 0.094583, train_acc: 0.996273, val_acc: 0.986400 iter: 360, loss: 0.094141, train_acc: 0.996455, val_acc: 0.986800 iter: 380, loss: 0.093763, train_acc: 0.996673, val_acc: 0.986600 iter: 400, loss: 0.093387, train_acc: 0.996673, val_acc: 0.986600 In [6]: # Plot the loss function and train / validation accuracies plt . subplot ( 2 , 1 , 1 ) plt . plot ( loss_history ) plt . title ( 'Loss history' ) plt . xlabel ( 'Iteration' ) plt . ylabel ( 'Loss' ) plt . subplot ( 2 , 1 , 2 ) plt . plot ( train_acc_history ) plt . plot ( val_acc_history ) plt . legend ([ 'Training accuracy' , 'Validation accuracy' ], loc = 'lower right' ) plt . xlabel ( 'Iteration' ) plt . ylabel ( 'Clasification accuracy' ) Out[6]: <matplotlib.text.Text at 0x10b853278> In [7]: # Visualize the weights W0 = weights [ 0 ][ 'W' ] image = display_network ( W0 . T ) plt . imshow ( image , cmap = plt . cm . gray ) Out[7]: <matplotlib.image.AxesImage at 0x10b91da20> In [8]: # Make predictions pred = clf . predict ( X_test ) acc = np . mean ( y_test == pred ) print ( \"Accuracy: {:5.2f}% \\n \" . format ( acc * 100 )) Accuracy: 98.19% In [9]: # View some images and predictions n_images = 4 images = X_test [:, : n_images ] . reshape (( 28 , 28 , n_images )) pred = clf . predict ( X_test [:, : n_images ]) for i in range ( n_images ): plt . subplot ( 1 , n_images , i + 1 ) plt . imshow ( images [:, :, i ], cmap = plt . cm . gray ) plt . title ( 'Predicted digit: {}' . format ( pred [ i ])) plt . axis ( 'off' ) Multilayer perceptron import numpy as np import scipy.optimize from dnn_play.activations import tanh, tanh_deriv, sigmoid, sigmoid_deriv from dnn_play.utils.np_utils import to_binary_class_matrix from dnn_play.utils.gradient_utils import eval_numerical_gradient, rel_norm_diff def f_ac(x): return sigmoid(x) #return tanh(x) def df_ac(x): return sigmoid_deriv(x) #return tanh_deriv(x) class MLP(object): \"\"\" Multilayer perceptron. \"\"\" def __init__(self, layer_units, weights=None): self.weights = weights self.layer_units = layer_units def init_weights(self, eps=1e-4): \"\"\" Initialize weights. layer_units: tuple stores the size of each layer. weights: structured weights. \"\"\" layer_units = self.layer_units n_layers = len(layer_units) weights = [{} for i in range(n_layers - 1)] for i in range(n_layers - 1): weights[i]['W'] = eps * np.random.randn(layer_units[i+1], layer_units[i]) weights[i]['b'] = np.zeros(layer_units[i+1]) self.weights = weights return self.weights def fit(self, X, y, X_val, y_val, reg=0.0, learning_rate=1e-2, optimizer='L-BFGS-B', max_iters=100, sample_batches=True, n_epochs=30, batch_size=128, verbose=False): epoch = 0 best_val_acc = 0.0 best_weights = {} input_size, n_train = X.shape n_classes = np.max(y) + 1 # assume y takes values 0...K-1 where K is number of classes if self.weights is None: # lazily initialize weights self.weights = self.init_weights() # Solve with L-BFGS-B options = {'maxiter': max_iters, 'disp': verbose} def J(theta): weights = pack_struct(theta, self.layer_units) loss, grad = mlp_loss(weights, X, y, reg) grad = flatten_struct(grad) return loss, grad # Callback to get accuracies based on training / validation sets iter_feval = 0 loss_history = [] train_acc_history = [] val_acc_history = [] def progress(x): nonlocal iter_feval, best_weights, best_val_acc iter_feval += 1 # Loss history weights = pack_struct(x, self.layer_units) loss, grad = mlp_loss(weights, X, y, reg) loss_history.append(loss) # Training accurary y_pred_train = mlp_predict(weights, X) train_acc = np.mean(y_pred_train == y) train_acc_history.append(train_acc) # Validation accuracy y_pred_val= mlp_predict(weights, X_val) val_acc = np.mean(y_pred_val == y_val) val_acc_history.append(val_acc) # Keep track of the best weights based on validation accuracy if val_acc > best_val_acc: best_val_acc = val_acc n_weights = len(weights) best_weights = [{} for i in range(n_weights)] for i in range(n_weights): for p in weights[i]: best_weights[i][p] = weights[i][p].copy() n_iters_verbose = max_iters / 20 if iter_feval % n_iters_verbose == 0: print(\"iter: {:4d}, loss: {:8f}, train_acc: {:4f}, val_acc: {:4f}\".format(iter_feval, loss, train_acc, val_acc)) # Minimize the loss function init_theta = flatten_struct(self.weights) results = scipy.optimize.minimize(J, init_theta, method=optimizer, jac=True, callback=progress, options=options) # Save weights self.weights = best_weights return self.weights, loss_history, train_acc_history, val_acc_history def predict(self, X): \"\"\" X: the N x M input matrix, where each column data[:, i] corresponds to a single test set pred: the predicted results. \"\"\" pred = mlp_predict(self.weights, X) return pred def flatten_struct(self, data): return flatten_struct(data) def pack_struct(self, data): return pack_struct(data, self.layer_units) def mlp_loss(weights, X, y, reg): \"\"\" Compute loss and gradients of the neutral network. \"\"\" L = len(weights) # The index of the output layer z = [] a = [] err_tol = 1e-10 # Error of tolerance # Number of samples m = X.shape[1] # Forward pass z.append(0) # Dummy element a.append(X) # Input activation for i in range(0, L): W = weights[i]['W'] b = weights[i]['b'] z.append(W.dot(a[-1]) + b.reshape((-1, 1))) a.append(f_ac(z[-1])) # Note the final element in a[:] will not be used zL_max = np.max(z[-1], axis=0) z[-1] -= zL_max # Avoid numerical problem due to large values of exp(z[-1]) proba = np.exp(z[-1]) / np.sum(np.exp(z[-1]), axis=0) + err_tol # Add err_tol to avoid this value too close to zero # Target matrix of labels target = to_binary_class_matrix(y) # Cost function sum_weight_square = 0.0 # Sum of weight square for i in range(L): W = weights[i]['W'] sum_weight_square += np.sum(W*W) cost = -1.0/m * np.sum(target * np.log(proba)) + 0.5*reg*sum_weight_square # Backpropagation delta = [-1.0 * (target - proba)] for i in reversed(range(L)): # Note that delta[0] will not be used W = weights[i]['W'] d = W.T.dot(delta[0])*df_ac(z[i]) delta.insert(0, d) # Insert element at beginning # Gradients grad = [{} for i in range(L)] for i in range(L): W = weights[i]['W'] grad[i]['W'] = delta[i+1].dot(a[i].T) / m + reg*W grad[i]['b'] = np.mean(delta[i+1], axis=1) return cost, grad def mlp_predict(weights, X): \"\"\" X: the N x M input matrix, where each column data[:, i] corresponds to a single test set pred: the predicted results. \"\"\" L = len(weights) # The index of the output layer z = [] a = [] err_tol = 1e-10 # Error of tolerance # Number of samples m = X.shape[1] # Forward pass z.append(0) # Dummy element a.append(X) # Input activation for i in range(0, L): W = weights[i]['W'] b = weights[i]['b'] z.append(W.dot(a[-1]) + b.reshape((-1, 1))) a.append(f_ac(z[-1])) # Note the final element in a[:] will not be used zL_max = np.max(z[-1], axis=0) z[-1] -= zL_max # Avoid numerical problem due to large values of exp(z[-1]) proba = np.exp(z[-1]) / np.sum(np.exp(z[-1]), axis=0) + err_tol # Add err_tol to avoid this value too close to zero # Predictions pred = np.argmax(proba, axis=0) return pred def flatten_struct(data): \"\"\" Flatten the data structure. \"\"\" n_data = len(data) # Data vector data_vec = np.concatenate((data[0]['W'].flatten(), data[0]['b'].flatten())) out = data_vec for i in range(1, n_data): data_vec = np.concatenate((data[i]['W'].flatten(), data[i]['b'].flatten())) out = np.concatenate((out, data_vec)) return out def pack_struct(data, layer_units): \"\"\" Pack the flattened data with structure. \"\"\" n_layers = len(layer_units) struct = [{} for i in range(n_layers - 1)] iz = 0 for i in range(n_layers - 1): ia = iz; iz = ia + layer_units[i+1]*layer_units[i] struct[i]['W'] = data[ia:iz].reshape((layer_units[i+1], layer_units[i])) ia = iz; iz = ia + layer_units[i+1] struct[i]['b'] = data[ia:iz] return struct def rel_err_gradients(): \"\"\" Return the relative error between analytic gradients and nemerical ones. \"\"\" # Number of layer units input_size = 4 * 4 hidden_size_L1 = 4 hidden_size_L2 = 4 output_size = 10 layer_units = (input_size, hidden_size_L1, hidden_size_L2, output_size) X_train = np.random.randn(input_size, 100) y_train = np.random.randint(output_size, size=100) reg = 1e-4 # Define the classifier clf = MLP(layer_units) # Initialize weights weights = clf.init_weights() # Analytic gradients of the cost function cost, grad = mlp_loss(weights, X_train, y_train, reg) grad = clf.flatten_struct(grad) # Flattened gradients def J(theta): # Structured weights weights = clf.pack_struct(theta) return mlp_loss(weights, X_train, y_train, reg)[0] theta = clf.flatten_struct(weights) numerical_grad = eval_numerical_gradient(J, theta) # Compare numerically computed gradients with those computed analytically rel_err = rel_norm_diff(numerical_grad, grad) return rel_err In case you are interested in all codes related in this demonstration, please check the repository .","url":"http://tsaith.github.io/implement-multilayer-perceptron-for-digit-recognition.html"},{"tags":"Machine learning","title":"Implement softmax regression for digit recognition","text":"This post will demonstrate how to implement softmax regression for digit recognition. The detailed derivations of algorithm can be found from my script . Main workflow Preparing training/validation/testing datasets. Set the weight decay / numerical parameters. Check if the gradients of the loss function are correct. Training model. Estimate the accuracy of prediction. Ipython notebook In [1]: % load_ext autoreload % autoreload 2 % matplotlib inline import numpy as np import matplotlib.pyplot as plt from dnn_play.classifiers.softmax import Softmax , softmax_loss , rel_err_gradients from dnn_play.utils.data_utils import load_mnist from dnn_play.utils.visualize_utils import display_network # Plot settings plt . rcParams [ 'figure.figsize' ] = ( 10.0 , 10.0 ) # set default size of plots plt . rcParams [ 'image.interpolation' ] = 'nearest' In [2]: # Load MNIST data ( X_train , y_train ), ( X_val , y_val ), ( X_test , y_test ) = load_mnist () #(X_train, y_train), (X_val, y_val), (X_test, y_test) = load_mnist(n_train=9000, n_val=1000, n_test=1000) print ( \"X_train shape = {} y_train shape = {}\" . format ( X_train . shape , y_train . shape )) print ( \"X_val shape = {} y_val shape = {}\" . format ( X_val . shape , y_val . shape )) print ( \"X_test shape = {} y_test shape = {}\" . format ( X_test . shape , y_test . shape )) X_train shape = (784, 55000) y_train shape = (55000,) X_val shape = (784, 5000) y_val shape = (5000,) X_test shape = (784, 10000) y_test shape = (10000,) In [3]: # Sanity check of softmax loss function # Number of layer units input_size = X_train . shape [ 0 ] # Dimension of features n_classes = np . max ( y_train ) + 1 layer_units = ( input_size , n_classes ) # Hyperparameters reg = 1 e - 4 # Numerical parameters max_iters = 400 # Define classifier clf = Softmax ( layer_units ) weights = clf . init_weights () loss , grad = softmax_loss ( weights , X_train , y_train , 0.0 ) # Note there are 10 classes. # As a rough sanity check, our loss should be something close to -log(0.1). print ( 'loss: %f' % loss ) print ( 'sanity check: %f' % ( - np . log ( 0.1 ))) loss: 2.302622 sanity check: 2.302585 In [4]: # Gradient checking if rel_err_gradients () < 1 e - 8 : print ( \"Gradient check passed!\" ) else : print ( \"Gradient check failed!\" ) Gradient check passed! In [5]: \"\"\" Training \"\"\" model , loss_history , train_acc_history , val_acc_history = clf . fit ( X_train , y_train , X_val , y_val , reg = reg , max_iters = max_iters , verbose = True ) iter: 20, loss: 0.325899, train_acc: 0.909036, val_acc: 0.928800 iter: 40, loss: 0.283475, train_acc: 0.923764, val_acc: 0.936000 iter: 60, loss: 0.271253, train_acc: 0.927873, val_acc: 0.939600 iter: 80, loss: 0.266398, train_acc: 0.930273, val_acc: 0.941400 iter: 100, loss: 0.264352, train_acc: 0.931582, val_acc: 0.941000 iter: 120, loss: 0.263492, train_acc: 0.932782, val_acc: 0.942000 iter: 140, loss: 0.263079, train_acc: 0.932873, val_acc: 0.941400 iter: 160, loss: 0.262900, train_acc: 0.933000, val_acc: 0.942400 iter: 180, loss: 0.262810, train_acc: 0.933109, val_acc: 0.942400 iter: 200, loss: 0.262773, train_acc: 0.933127, val_acc: 0.942400 iter: 220, loss: 0.262754, train_acc: 0.933018, val_acc: 0.942200 iter: 240, loss: 0.262747, train_acc: 0.933018, val_acc: 0.942600 iter: 260, loss: 0.262743, train_acc: 0.933073, val_acc: 0.942400 In [6]: # Plot the loss function and train / validation accuracies plt . subplot ( 2 , 1 , 1 ) plt . plot ( loss_history ) plt . title ( 'Loss history' ) plt . xlabel ( 'Iteration' ) plt . ylabel ( 'Loss' ) plt . subplot ( 2 , 1 , 2 ) plt . plot ( train_acc_history ) plt . plot ( val_acc_history ) plt . legend ([ 'Training accuracy' , 'Validation accuracy' ], loc = 'lower right' ) plt . xlabel ( 'Iteration' ) plt . ylabel ( 'Clasification accuracy' ) Out[6]: <matplotlib.text.Text at 0x109e8f4e0> In [7]: # Visualize the weights W0 = model [ 0 ][ 'W' ] image = display_network ( W0 . T ) plt . imshow ( image , cmap = plt . cm . gray ) Out[7]: <matplotlib.image.AxesImage at 0x10b22e6d8> In [8]: # Make predictions pred = clf . predict ( X_test ) acc = np . mean ( y_test == pred ) print ( \"Accuracy: {:5.2f}% \\n \" . format ( acc * 100 )) Accuracy: 92.54% In [9]: # View some images and predictions n_images = 3 images = X_test [:, : n_images ] . reshape (( 28 , 28 , n_images )) pred = clf . predict ( X_test [:, : n_images ]) for i in range ( n_images ): plt . subplot ( 1 , n_images , i + 1 ) plt . imshow ( images [:, :, i ], cmap = plt . cm . gray ) plt . title ( 'Predicted digit: {}' . format ( pred [ i ])) plt . axis ( 'off' ) Softmax classifier import numpy as np import scipy.optimize from dnn_play.utils.np_utils import to_binary_class_matrix, flatten_struct, pack_struct from dnn_play.utils.gradient_utils import eval_numerical_gradient, rel_norm_diff class Softmax(object): \"\"\" Softmax classifer \"\"\" def __init__(self, layer_units, weights=None): self.weights = weights self.layer_units = layer_units def init_weights(self, eps=1e-4): self.weights = init_weights(self.layer_units, eps=eps) return self.weights def fit(self, X, y, X_val, y_val, reg=0.0, optimizer='L-BFGS-B', max_iters=100, verbose=False): epoch = 0 best_val_acc = 0.0 best_weights = {} input_size, n_train = X.shape n_classes = np.max(y) + 1 # assume y takes values 0...K-1 where K is number of classes if self.weights is None: # lazily initialize weights self.weights = init_weights(self.layer_units) # Solve with L-BFGS-B options = {'maxiter': max_iters, 'disp': verbose} def J(theta): weights = pack_struct(theta, self.layer_units) loss, grad = softmax_loss(weights, X, y, reg) grad = flatten_struct(grad) return loss, grad # Callback to get accuracies based on training / validation sets iter_feval = 0 loss_history = [] train_acc_history = [] val_acc_history = [] def progress(x): nonlocal iter_feval, best_weights, best_val_acc iter_feval += 1 # Loss history weights = pack_struct(x, self.layer_units) loss, grad = softmax_loss(weights, X, y, reg) loss_history.append(loss) # Training accurary y_pred_train = softmax_predict(weights, X) train_acc = np.mean(y_pred_train == y) train_acc_history.append(train_acc) # Validation accuracy y_pred_val= softmax_predict(weights, X_val) val_acc = np.mean(y_pred_val == y_val) val_acc_history.append(val_acc) # Keep track of the best weights based on validation accuracy if val_acc > best_val_acc: best_val_acc = val_acc n_weights = len(weights) best_weights = [{} for i in range(n_weights)] for i in range(n_weights): for p in weights[i]: best_weights[i][p] = weights[i][p].copy() n_iters_verbose = max_iters / 20 if iter_feval % n_iters_verbose == 0: print(\"iter: {:4d}, loss: {:8f}, train_acc: {:4f}, val_acc: {:4f}\".format(iter_feval, loss, train_acc, val_acc)) # Minimize the loss function init_theta = flatten_struct(self.weights) results = scipy.optimize.minimize(J, init_theta, method=optimizer, jac=True, callback=progress, options=options) # Save weights self.weights = best_weights return self.weights, loss_history, train_acc_history, val_acc_history def predict(self, X): \"\"\" X: the N x M input matrix, where each column data[:, i] corresponds to a single test set pred: the predicted results. \"\"\" pred = softmax_predict(self.weights, X) return pred def flatten_struct(self, data): return flatten_struct(data) def pack_struct(self, data): return pack_struct(data, self.layer_units) def get_weights(self): return self.weights def softmax_loss(weights, X, y, reg): \"\"\" Compute the loss and derivative. theta: weight matrix X: the N x M input matrix, where each column data[:, i] corresponds to a single test set y: labels corresponding to the input data \"\"\" # Small constant used to avoid numerical problem eps = 1e-10 # Weighting parameters W0 = weights[0]['W'] b0 = weights[0]['b'] # Number of samples m = X.shape[1] # Forward pass a0 = X # Input activation z1 = W0.dot(a0) + b0.reshape((-1, 1)) z1_max = np.max(z1, axis=0) z1 -= z1_max # Avoid numerical problem due to large values of exp(z1) proba = np.exp(z1) / np.sum(np.exp(z1), axis=0) + eps # Add eps to avoid this value too close to zero # Target matrix of labels target = to_binary_class_matrix(y) # Cost function cost = -1.0/m * np.sum(target* np.log(proba)) + 0.5*reg*np.sum(W0*W0) # Gradients delta1 = -1.0 * (target - proba) grad = [{}] grad[0]['W'] = delta1.dot(a0.T)/m + reg*W0 grad[0]['b'] = np.mean(delta1, axis=1) return cost, grad def softmax_predict(weights, X): \"\"\" weights: weights trained using softmax_train X: the test matrix, where each column X[:, i] corresponds to a single test set pred: the prediction array. \"\"\" # Small constant used to avoid numerical problem eps = 1e-10 # Weighting parameters W0 = weights[0]['W'] b0 = weights[0]['b'] # Number of samples m = X.shape[1] # Forward pass a0 = X # Input activation z1 = W0.dot(a0) + b0.reshape((-1, 1)) # Propabilities z1_max = np.max(z1, axis=0) z1 -= z1_max # Avoid numerical problem due to large values of exp(z1) proba = np.exp(z1) / np.sum(np.exp(z1), axis=0) + eps # Add eps to avoid this value too close to zero # Predictions pred = np.argmax(proba, axis=0) return pred def init_weights(layer_units, eps=1e-4): \"\"\" Initialize weights. layer_units: tuple stores the size of each layer. weights: structured weights. \"\"\" assert len(layer_units) == 2 weights = [{}] weights[0]['W'] = eps * np.random.randn(layer_units[1], layer_units[0]) weights[0]['b'] = np.zeros(layer_units[1]) return weights def rel_err_gradients(): \"\"\" Return the relative error between analytic gradients and nemerical ones. \"\"\" # Number of layer units input_size = 4 * 4 hidden_size = 4 n_classes = 10 layer_units = (input_size, n_classes) X_train = np.random.randn(input_size, 100) y_train = np.random.randint(n_classes, size=100) reg = 1e-4 # Define the classifier clf = Softmax(layer_units) # Initialize weights weights = clf.init_weights() # Analytic gradients of the cost function cost, grad = softmax_loss(weights, X_train, y_train, reg) grad = clf.flatten_struct(grad) # Flattened gradients def J(theta): # Structured weights weights = clf.pack_struct(theta) return softmax_loss(weights, X_train, y_train, reg)[0] theta = clf.flatten_struct(weights) numerical_grad = eval_numerical_gradient(J, theta) # Compare numerically computed gradients with those computed analytically rel_err = rel_norm_diff(numerical_grad, grad) return rel_err In case you are interested in all codes related in this demonstration, please check the repository .","url":"http://tsaith.github.io/implement-softmax-regression-for-digit-recognition.html"},{"tags":"Machine learning","title":"Implement a neural network for digit recognition","text":"This post will demonstrate how to implement a three-layers neural network for digit recognition. The detailed derivations of algorithm can be found from my script . Main workflow Preparing training/validation/testing datasets. Set the weight decay / numerical parameters. Check if the gradients of the loss function are correct. Training model. Estimate the accuracy of prediction. Ipython notebook In [1]: % load_ext autoreload % autoreload 2 % matplotlib inline import numpy as np import matplotlib.pyplot as plt from dnn_play.classifiers.neural_net import NeuralNet , neural_net_loss , rel_err_gradients from dnn_play.utils.data_utils import load_mnist from dnn_play.utils.visualize_utils import display_network # Plot settings plt . rcParams [ 'figure.figsize' ] = ( 10.0 , 10.0 ) # set default size of plots plt . rcParams [ 'image.interpolation' ] = 'nearest' In [2]: # Load MNIST data ( X_train , y_train ), ( X_val , y_val ), ( X_test , y_test ) = load_mnist () #(X_train, y_train), (X_val, y_val), (X_test, y_test) = load_mnist(n_train=5500, n_val=500, n_test=1000) print ( \"X_train shape = {} y_train shape = {}\" . format ( X_train . shape , y_train . shape )) print ( \"X_val shape = {} y_val shape = {}\" . format ( X_val . shape , y_val . shape )) print ( \"X_test shape = {} y_test shape = {}\" . format ( X_test . shape , y_test . shape )) X_train shape = (784, 55000) y_train shape = (55000,) X_val shape = (784, 5000) y_val shape = (5000,) X_test shape = (784, 10000) y_test shape = (10000,) In [3]: # Number of layer units input_size = X_train . shape [ 0 ] # Dimension of features hidden_size = 28 n_classes = np . max ( y_train ) + 1 layer_units = (( input_size , hidden_size , n_classes )) # Hyperparameters reg = 1 e - 4 # Regulation, weight decay # Numerical parameters max_iters = 400 # Initialize weights clf = NeuralNet ( layer_units ) weights = clf . init_weights () loss , grad = neural_net_loss ( weights , X_train , y_train , reg ) print ( 'loss: %f' % loss ) loss: 1.249960 In [4]: # Gradient checking if rel_err_gradients () < 1 e - 8 : print ( \"Gradient check passed!\" ) else : print ( \"Gradient check failed!\" ) Gradient check passed! In [5]: \"\"\" Training \"\"\" weights , loss_history , train_acc_history , val_acc_history = clf . fit ( X_train , y_train , X_val , y_val , reg = reg , max_iters = max_iters , verbose = True ) iter: 20, loss: 0.419866, train_acc: 0.271382, val_acc: 0.275600 iter: 40, loss: 0.227288, train_acc: 0.701836, val_acc: 0.721800 iter: 60, loss: 0.146925, train_acc: 0.830582, val_acc: 0.853400 iter: 80, loss: 0.125238, train_acc: 0.852873, val_acc: 0.867800 iter: 100, loss: 0.096621, train_acc: 0.925655, val_acc: 0.944400 iter: 120, loss: 0.084912, train_acc: 0.940091, val_acc: 0.952800 iter: 140, loss: 0.081210, train_acc: 0.947855, val_acc: 0.960000 iter: 160, loss: 0.079193, train_acc: 0.951855, val_acc: 0.961800 iter: 180, loss: 0.078076, train_acc: 0.954109, val_acc: 0.963200 iter: 200, loss: 0.077142, train_acc: 0.955709, val_acc: 0.964800 iter: 220, loss: 0.076304, train_acc: 0.957345, val_acc: 0.966200 iter: 240, loss: 0.075594, train_acc: 0.958964, val_acc: 0.968400 iter: 260, loss: 0.075044, train_acc: 0.959473, val_acc: 0.968200 iter: 280, loss: 0.074649, train_acc: 0.960309, val_acc: 0.967000 iter: 300, loss: 0.074324, train_acc: 0.960764, val_acc: 0.968000 iter: 320, loss: 0.074067, train_acc: 0.961273, val_acc: 0.969000 iter: 340, loss: 0.073854, train_acc: 0.961636, val_acc: 0.968200 iter: 360, loss: 0.073678, train_acc: 0.961764, val_acc: 0.968800 iter: 380, loss: 0.073546, train_acc: 0.962364, val_acc: 0.969600 iter: 400, loss: 0.073417, train_acc: 0.962582, val_acc: 0.968200 In [6]: # Plot the loss function and train / validation accuracies plt . subplot ( 2 , 1 , 1 ) plt . plot ( loss_history ) plt . title ( 'Loss history' ) plt . xlabel ( 'Iteration' ) plt . ylabel ( 'Loss' ) plt . subplot ( 2 , 1 , 2 ) plt . plot ( train_acc_history ) plt . plot ( val_acc_history ) plt . legend ([ 'Training accuracy' , 'Validation accuracy' ], loc = 'lower right' ) plt . xlabel ( 'Iteration' ) plt . ylabel ( 'Clasification accuracy' ) Out[6]: <matplotlib.text.Text at 0x1137ca390> In [7]: # Visualize the weights W0 = weights [ 0 ][ 'W' ] image = display_network ( W0 . T ) plt . imshow ( image , cmap = plt . cm . gray ) Out[7]: <matplotlib.image.AxesImage at 0x11381e400> In [8]: # Make predictions pred = clf . predict ( X_test ) acc = np . mean ( y_test == pred ) print ( \"Accuracy: {:5.2f}% \\n \" . format ( acc * 100 )) Accuracy: 95.87% In [9]: # View some images and predictions n_images = 3 images = X_test [:, : n_images ] . reshape (( 28 , 28 , n_images )) pred = clf . predict ( X_test [:, : n_images ]) for i in range ( n_images ): plt . subplot ( 1 , n_images , i + 1 ) plt . imshow ( images [:, :, i ], cmap = plt . cm . gray ) plt . title ( 'Predicted digit: {}' . format ( pred [ i ])) plt . axis ( 'off' ) NeuralNet classifier import numpy as np import scipy.optimize from dnn_play.activations import sigmoid, sigmoid_deriv from dnn_play.utils.np_utils import to_binary_class_matrix, flatten_struct, pack_struct from dnn_play.utils.gradient_utils import eval_numerical_gradient, rel_norm_diff def ac_func(x): return sigmoid(x) def ac_func_deriv(x): return sigmoid_deriv(x) class NeuralNet(object): \"\"\" Classifier of the neural network. \"\"\" def __init__(self, layer_units, weights=None): self.weights = weights self.layer_units = layer_units def init_weights(self, eps=1e-4): \"\"\" Initialize weights. layer_units: tuple stores the size of each layer. weights: structured weights. \"\"\" layer_units = self.layer_units n_layers = len(layer_units) weights = [{} for i in range(n_layers - 1)] for i in range(n_layers - 1): weights[i]['W'] = eps * np.random.randn(layer_units[i+1], layer_units[i]) weights[i]['b'] = np.zeros(layer_units[i+1]) self.weights = weights return self.weights def fit(self, X, y, X_val, y_val, reg=0.0, learning_rate=1e-2, optimizer='L-BFGS-B', max_iters=100, sample_batches=True, n_epochs=30, batch_size=128, verbose=False): epoch = 0 best_val_acc = 0.0 best_weights = {} input_size, n_train = X.shape n_classes = np.max(y) + 1 # assume y takes values 0...K-1 where K is number of classes if self.weights is None: # lazily initialize weights self.weights = self.init_weights() # Solve with L-BFGS-B options = {'maxiter': max_iters, 'disp': verbose} def J(theta): weights = pack_struct(theta, self.layer_units) loss, grad = neural_net_loss(weights, X, y, reg) grad = flatten_struct(grad) return loss, grad # Callback to get accuracies based on training / validation sets iter_feval = 0 loss_history = [] train_acc_history = [] val_acc_history = [] def progress(x): nonlocal iter_feval, best_weights, best_val_acc iter_feval += 1 # Loss history weights = pack_struct(x, self.layer_units) loss, grad = neural_net_loss(weights, X, y, reg) loss_history.append(loss) # Training accurary y_pred_train = neural_net_predict(weights, X) train_acc = np.mean(y_pred_train == y) train_acc_history.append(train_acc) # Validation accuracy y_pred_val= neural_net_predict(weights, X_val) val_acc = np.mean(y_pred_val == y_val) val_acc_history.append(val_acc) # Keep track of the best weights based on validation accuracy if val_acc > best_val_acc: best_val_acc = val_acc n_weights = len(weights) best_weights = [{} for i in range(n_weights)] for i in range(n_weights): for p in weights[i]: best_weights[i][p] = weights[i][p].copy() n_iters_verbose = max_iters / 20 if iter_feval % n_iters_verbose == 0: print(\"iter: {:4d}, loss: {:8f}, train_acc: {:4f}, val_acc: {:4f}\".format(iter_feval, loss, train_acc, val_acc)) # Minimize the loss function init_theta = flatten_struct(self.weights) results = scipy.optimize.minimize(J, init_theta, method=optimizer, jac=True, callback=progress, options=options) # Save weights self.weights = best_weights return self.weights, loss_history, train_acc_history, val_acc_history def predict(self, X): \"\"\" X: the N x M input matrix, where each column data[:, i] corresponds to a single test set pred: the predicted results. \"\"\" pred = neural_net_predict(self.weights, X) return pred def flatten_struct(self, data): return flatten_struct(data) def pack_struct(self, data): return pack_struct(data, self.layer_units) def neural_net_loss(weights, X, y, reg): \"\"\" Compute loss and gradients of the neutral network. \"\"\" Y = to_binary_class_matrix(y) L = len(weights) # The index of the output layer z = [] a = [] # Number of samples m = X.shape[1] # Forward pass z.append(0) # Dummy element a.append(X) # Input activation for i in range(0, L): W = weights[i]['W'] b = weights[i]['b'] z.append(W.dot(a[-1]) + b.reshape((-1, 1))) a.append(ac_func(z[-1])) # Cost function sum_weight_square = 0.0 # Sum of weight square for i in range(L): W = weights[i]['W'] sum_weight_square += np.sum(W*W) cost = 1.0/(2.0*m) * np.sum((a[-1] - Y)**2) + 0.5*reg*sum_weight_square # Backpropagation delta = [(a[-1] - Y) * ac_func_deriv(z[-1])] for i in reversed(range(L)): # Note that delta[0] will not be used W = weights[i]['W'] d = W.T.dot(delta[0]) * ac_func_deriv(z[i]) delta.insert(0, d) # Insert element at beginning # Gradients grad = [{} for i in range(L)] for i in range(L): W = weights[i]['W'] grad[i]['W'] = delta[i+1].dot(a[i].T) / m + reg*W grad[i]['b'] = np.mean(delta[i+1], axis=1) return cost, grad def neural_net_predict(weights, X): \"\"\" X: the N x M input matrix, where each column data[:, i] corresponds to a single test set pred: the predicted results. \"\"\" L = len(weights) # The index of the output layer z = [] a = [] # Number of samples m = X.shape[1] # Forward pass z.append(0) # Dummy element a.append(X) # Input activation for i in range(0, L): W = weights[i]['W'] b = weights[i]['b'] z.append(W.dot(a[-1]) + b.reshape((-1, 1))) a.append(ac_func(z[-1])) # Predictions pred = np.argmax(a[-1], axis=0) return pred def rel_err_gradients(): \"\"\" Return the relative error between analytic and nemerical gradients. \"\"\" # Number of layer units input_size = 4 * 4 hidden_size = 4 n_classes = 10 layer_units = (input_size, hidden_size, n_classes) X_train = np.random.randn(input_size, 100) y_train = np.random.randint(n_classes, size=100) reg = 1e-4 # Define the classifier clf = NeuralNet(layer_units) # Initialize weights weights = clf.init_weights() # Analytic gradients of the cost function cost, grad = neural_net_loss(weights, X_train, y_train, reg) grad = clf.flatten_struct(grad) # Flattened gradients def J(theta): # Structured weights weights = clf.pack_struct(theta) return neural_net_loss(weights, X_train, y_train, reg)[0] theta = clf.flatten_struct(weights) numerical_grad = eval_numerical_gradient(J, theta) # Compare numerically computed gradients with those computed analytically rel_err = rel_norm_diff(numerical_grad, grad) return rel_err In case you are interested in all codes related in this demonstration, please check the repository .","url":"http://tsaith.github.io/implement-a-neural-network-for-digit-recognition.html"},{"tags":"Machine learning","title":"Install Theano and CUDA Toolkit 7.5 on OSX","text":"This post describes the steps I used to install Theano on my Mac (OSX 10.9.5) with NVIDIA GeForce GTX 660M graphics card. Install Theano Please use pip to install Theano as below $ pip install Theano Then, create the ~/.theanorc with content as [global] mode = FAST_RUN floatX = float32 device = gpu [nvcc] fastmath = True Install CUDA Toolkit Download the package of CUDA Toolkit 7.5 from the official link . Install cuDNN Next, we have to register on NVIDIA to be able to download cuDNN , which is a GPU-accelerated library of primitives for deep neural networks. After downloading, please uncompress the package and copy the header file and libraries to include and lib under the root directory of CUDA Toolkit (e.g. /usr/local/cuda), respectively. $ tar xzf cudnn-7.0-osx-x64-v3.0-prod.tgz $ cd cuda $ sudo cp include/cudnn.h /usr/local/cuda/include/ $ sudo cp lib/libcudnn* /usr/local/cuda/lib/ Add environment variables Add the following environment variables to ~/.bash_profile . # Theano export CUDA_ROOT=\"/usr/local/cuda\" export THEANO_FLAGS=\"mode=FAST_RUN,device=gpu,floatX=float32\" # CUDA export LD_LIBRARY_PATH=\" $ CUDA_ROOT /lib: $ LD_LIBRARY_PATH \" export PATH=\" $ CUDA_ROOT /bin: $ PATH \" You may want to execute source ~/.bash_profile to validate the settings right away. Testing Now, we can run a test code to see if the Theano works as expected. test.py: from theano import function , config , shared , sandbox import theano.tensor as T import numpy import time vlen = 10 * 30 * 768 # 10 x #cores x # threads per core iters = 1000 rng = numpy . random . RandomState ( 22 ) x = shared ( numpy . asarray ( rng . rand ( vlen ), config . floatX )) f = function ([], T . exp ( x )) print ( f . maker . fgraph . toposort ()) t0 = time . time () for i in range ( iters ): r = f () t1 = time . time () print ( \"Looping %d times took %f seconds\" % ( iters , t1 - t0 )) print ( \"Result is %s \" % ( r ,)) if numpy . any ([ isinstance ( x . op , T . Elemwise ) for x in f . maker . fgraph . toposort ()]): print ( 'Used the cpu' ) else : print ( 'Used the gpu' ) Let's run this code on CPU and GPU, separately. CPU case: $ THEANO_FLAGS = 'device=cpu' python test.py [ Elemwise { exp,no_inplace }( <TensorType ( float32, vector ) > )] Looping 1000 times took 14.474722 seconds Result is [ 1.23178029 1.61879337 1.52278066 ..., 2.20771813 2.29967761 1.62323284 ] Used the cpu GPU case: $ THEANO_FLAGS = 'device=gpu' python test.py Using gpu device 0: GeForce GTX 660M ( CNMeM is disabled ) [ GpuElemwise { exp,no_inplace }( <CudaNdarrayType ( float32, vector ) > ) , HostFromGpu ( GpuElemwise { exp,no_inplace } .0 )] Looping 1000 times took 0.517552 seconds Result is [ 1.23178029 1.61879349 1.52278066 ..., 2.20771813 2.29967761 1.62323296 ] Used the gpu Please note that Theano will have to compile the python code to generate C++/CUDA code when executing with GPU for the first time. Thus, the results shown above came from the execution of the second time. Finally, it can be observed that the runtime is greatly reduced when GPU is used : )","url":"http://tsaith.github.io/install-theano-and-cuda-toolkit-75-on-osx.html"},{"tags":"Machine learning","title":"Implement the exercises of UFLDL Tutorial with python 3","text":"In recent years, deep learning has received more and more attention and is applied to many things in our daily life. Thus, I decide to dig into this powerful technology by self-teaching. Last month, I started to study UFLDL Tutorial which is an excellent learning material contributed by Andrew Ng . I really like his way to explain concepts and appreciate his generosity to carefully prepare the online courses. In UFLDL Tutorial, the exercises are originally supposed to be done with Matlab. However, I have no Matlab license. Thus, I chose python (with version 3.4) to implement those exercises. The codes and related introduction can be found here .","url":"http://tsaith.github.io/implement-the-exercises-of-ufldl-tutorial-with-python-3.html"},{"tags":"Machine learning","title":"A quick demo on face detection with python 3 and opencv 3","text":"Here, I record how to write a simple code for face detection with Harr-like features, which is based on python 3 and opencv 3. The script face_detector_haar.py below is just slightly modified from the post written by Shantnu Tiwari. face_detector_haar.py: import cv2 # OpenCV import sys # Input image image_path = sys . argv [ 1 ] # Model parameters dir_path = \"/usr/local/Cellar/opencv3/3.0.0/share/OpenCV/haarcascades\" # Please modify this for your environment filename = \"haarcascade_frontalface_default.xml\" # for frontal faces #filename = \"haarcascade_profileface.xml\" # for profile faces model_path = dir_path + \"/\" + filename # Create the classifier clf = cv2 . CascadeClassifier ( model_path ) # Read the image image = cv2 . imread ( image_path ) gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) # Detect faces on image faces = clf . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( 30 , 30 ), flags = cv2 . CASCADE_SCALE_IMAGE ) print ( \"Found {0} faces!\" . format ( len ( faces ))) # Draw a rectangle around the faces for ( x , y , w , h ) in faces : cv2 . rectangle ( image , ( x , y ), ( x + w , y + h ), ( 0 , 255 , 0 ), 2 ) cv2 . imshow ( \"Faces found\" , image ) cv2 . waitKey ( 0 ) Please make sure the model_path in code is correctly set when considering your OpenCV environment. The haarcascade_frontalface_default.xml and haarcascade_profileface.xml are the model files of frontal and profile face detection, respectively. To execute the script: python3 face_detector_haar.py photo.jpg Some results are demonstrated as following.","url":"http://tsaith.github.io/a-quick-demo-on-face-detection-with-python-3-and-opencv-3.html"},{"tags":"Machine learning","title":"A Python binding of Compressive Tracking","text":"Recently I read an interesting paper \"Real-time Compressive Tracking\" which applied compressive sensing on object tracking to dramatically reduce the calculations and showed remarkable results. Kaihua Zhang (the author) kindly had released the source code(both Matlab and C++ versions) of the algorithm on his webpage . A python binding Personally I prefer to test algorithms with python, hence, I have tried to build a python binding of compressive tracking and tested it on my Mac. Some results are as below: Kitesurf Bolt and the source code can be found from this link . More details This section will describe the main steps how I wrapped the C++ version of compressive tracking as the python binding and is not important in the aspect of usage. In case you are interested in the procedures, please keep reading. The class CompressiveTracker in compressive_tracker.cpp provides two public methods init(Mat& _frame, Rect& _objectBox) and processFrame(Mat& _frame, Rect& _objectBox) , where _frame and _objectBox are the video frame and object box, respectively. I added two public methods init_wrap(vector<vector<uint8> > &_frame, vector<int> &_object_box) and process_frame_wrap(vector<vector<uint8> > &_frame, vector<int> &_object_box) to wrap the methods init and processFrame , which expect vector array arguments instead of Mat or Rect ones. Next, the cython files wrap.pxd and wrap.pyx were created to wrap the C++ class CompressiveTracker into the Python class CyCompressiveTracker . Besides, setup.py was added for compilation. Finally, run.py is the testing code which will load the python binding for object tracking. Frankly speaking, the existences of init_wrap and process_frame_wrap come from that I don't know how to use cython to directly convert numpy array into Mat or Rect instances of OpenCv. I will grateful if someone can show me how to do that : )","url":"http://tsaith.github.io/a-python-binding-of-compressive-tracking.html"},{"tags":"Machine learning","title":"Combine images into a video with Python 3 and OpenCv 3","text":"Here, we will inspect a python script (named tk-img2video ) which will combine images into a video. tk-img2video: #!/usr/local/bin/python3 import cv2 import argparse import os # Construct the argument parser and parse the arguments ap = argparse . ArgumentParser () ap . add_argument ( \"-ext\" , \"--extension\" , required = False , default = 'png' , help = \"extension name. default is 'png'.\" ) ap . add_argument ( \"-o\" , \"--output\" , required = False , default = 'output.mp4' , help = \"output video file\" ) args = vars ( ap . parse_args ()) # Arguments dir_path = '.' ext = args [ 'extension' ] output = args [ 'output' ] images = [] for f in os . listdir ( dir_path ): if f . endswith ( ext ): images . append ( f ) # Determine the width and height from the first image image_path = os . path . join ( dir_path , images [ 0 ]) frame = cv2 . imread ( image_path ) cv2 . imshow ( 'video' , frame ) height , width , channels = frame . shape # Define the codec and create VideoWriter object fourcc = cv2 . VideoWriter_fourcc ( * 'mp4v' ) # Be sure to use lower case out = cv2 . VideoWriter ( output , fourcc , 20.0 , ( width , height )) for image in images : image_path = os . path . join ( dir_path , image ) frame = cv2 . imread ( image_path ) out . write ( frame ) # Write out frame to video cv2 . imshow ( 'video' , frame ) if ( cv2 . waitKey ( 1 ) & 0xFF ) == ord ( 'q' ): # Hit `q` to exit break # Release everything if job is finished out . release () cv2 . destroyAllWindows () print ( \"The output video is {}\" . format ( output )) Sample usage: tk-img2video -ext png -o output.mp4 It will combine all images with png file extension into a video file named output.mp4 .","url":"http://tsaith.github.io/combine-images-into-a-video-with-python-3-and-opencv-3.html"},{"tags":"Machine learning","title":"Write a python script to define the detecting region by clicking and dragging mouse","text":"In object tracking, usually, we need to define a rectangular box which contains the object of interest and obtain the box information as follows. Box: (80, 86, 263, 312) where (80, 86) is the upper-left point of box. The 263 and 312 are the width and height, respectively. And this work can be done by writing a simple script (named tk-detect-box ) as below. tk-detect-box: #!/usr/local/bin/python3 import cv2 import argparse import os class Rect : def __init__ ( self , x , y , width , height ): self . x = x self . y = x self . width = width self . height = height def detect_box ( image , win_name = \"window (hit q to exit)\" ): # Return a box for detection box_defined = False box = Rect ( 0 , 0 , 0 , 0 ) def define_box ( event , x , y , flags , param ): nonlocal box_defined , box if event == cv2 . EVENT_LBUTTONDOWN : box_defined = False box . x = x box . y = y box . width = 0 box . height = 0 if event == cv2 . EVENT_MOUSEMOVE : if not box_defined : box . width = x - box . x box . height = y - box . y if event == cv2 . EVENT_LBUTTONUP : box_defined = True def do_nothing ( event , x , y , flags , param ): pass # set mouse callback cv2 . setMouseCallback ( win_name , define_box ) while True : # display the frame from video capture clone = image . copy () if box . x > 0 and box . width > 0 : # Starting and ending point of the rectangle p0 = ( box . x , box . y ) p1 = ( box . x + box . width , box . y + box . height ) cv2 . rectangle ( clone , p0 , p1 , ( 0 , 255 , 0 ), thickness = 2 ) cv2 . imshow ( win_name , clone ) if ( cv2 . waitKey ( 1 ) & 0xFF ) == ord ( 'q' ): # Hit `q` to exit break # Set a mouse callback which does nothing cv2 . setMouseCallback ( win_name , do_nothing ) return box # Construct the argument parser and parse the arguments ap = argparse . ArgumentParser () ap . add_argument ( \"-i\" , \"--image\" , required = True , help = \"image path.\" ) args = vars ( ap . parse_args ()) # Arguments image_path = args [ 'image' ] # Determine the width and height from the first image image = cv2 . imread ( image_path ) # Create a window win_name = 'window (hit q to exit)' cv2 . namedWindow ( win_name ) # Define the detecting box box = detect_box ( image , win_name ) # Output box information print ( \"Box: ({}, {}, {}, {}) \" . format ( box . x , box . y , box . width , box . height )) cv2 . destroyAllWindows () { % endcodeblock % } The usage of this script is like tk-detect-box -i girl.png It will open the image and let you define a rectangular box by clicking and dragging the mouse. After hitting q and it will show out the box information.","url":"http://tsaith.github.io/write-a-python-script-to-define-the-detecting-region-by-clicking-and-dragging-mouse.html"},{"tags":"Machine learning","title":"Define a detection window on image with mouse through Python 3 and OpenCV 3","text":"For image recognition or object tracking, we often need to define a target window to locate the area interested as below. In this post, I would like to demonstrate how to use a mouse to define a rectangular window on the image with python 3 and OpenCV 3. The following sample code named target_win.py , which is slightly modified from the code in a great post written by Adrian Rosebrock. It shows an image for you to define a rectangular region as the target window with your mouse. After hitting the key c to confirm your selection, it will write out the starting and ending points of the target window. target_win.py: import cv2 from skimage import data def define_rect ( image ): \"\"\" Define a rectangular window by click and drag your mouse. Parameters ---------- image: Input image. \"\"\" clone = image . copy () rect_pts = [] # Starting and ending points win_name = \"image\" # Window name def select_points ( event , x , y , flags , param ): nonlocal rect_pts if event == cv2 . EVENT_LBUTTONDOWN : rect_pts = [( x , y )] if event == cv2 . EVENT_LBUTTONUP : rect_pts . append (( x , y )) # draw a rectangle around the region of interest cv2 . rectangle ( clone , rect_pts [ 0 ], rect_pts [ 1 ], ( 0 , 255 , 0 ), 2 ) cv2 . imshow ( win_name , clone ) cv2 . namedWindow ( win_name ) cv2 . setMouseCallback ( win_name , select_points ) while True : # display the image and wait for a keypress cv2 . imshow ( win_name , clone ) key = cv2 . waitKey ( 0 ) & 0xFF if key == ord ( \"r\" ): # Hit 'r' to replot the image clone = image . copy () elif key == ord ( \"c\" ): # Hit 'c' to confirm the selection break # close the open windows cv2 . destroyWindow ( win_name ) return rect_pts # Prepare an image for testing lena = data . lena () # A image array with RGB color channels lena = cv2 . cvtColor ( lena , cv2 . COLOR_BGR2RGB ) # Convert RGB to BGR # Points of the target window points = define_rect ( lena ) print ( \"--- target window ---\" ) print ( \"Starting point is \" , points [ 0 ]) print ( \"Ending point is \" , points [ 1 ]) In case you haven't installed skimage which is a useful library for image processing in python, it can be installed by executing pip3 install scikit-image","url":"http://tsaith.github.io/define-a-detection-window-on-image-with-mouse-through-python-3-and-opencv-3.html"},{"tags":"Machine learning","title":"Record video with Python 3 + OpenCV 3 on OSX","text":"This simple example will demonstrate how to use python + OpenCV 3 to capture frames from the webcam and save them as a video file of mp4 format on your Mac. import numpy as np import cv2 cap = cv2 . VideoCapture ( 0 ) # Capture video from camera # Get the width and height of frame width = int ( cap . get ( cv2 . CAP_PROP_FRAME_WIDTH ) + 0.5 ) height = int ( cap . get ( cv2 . CAP_PROP_FRAME_HEIGHT ) + 0.5 ) # Define the codec and create VideoWriter object fourcc = cv2 . VideoWriter_fourcc ( * 'mp4v' ) # Be sure to use the lower case out = cv2 . VideoWriter ( 'output.mp4' , fourcc , 20.0 , ( width , height )) while ( cap . isOpened ()): ret , frame = cap . read () if ret == True : frame = cv2 . flip ( frame , 0 ) # write the flipped frame out . write ( frame ) cv2 . imshow ( 'frame' , frame ) if ( cv2 . waitKey ( 1 ) & 0xFF ) == ord ( 'q' ): # Hit `q` to exit break else : break # Release everything if job is finished out . release () cap . release () cv2 . destroyAllWindows () After running the code, you should see a pop-up window displaying the flipped video captured by your webcam. Just hit the key q to terminate the execution.","url":"http://tsaith.github.io/record-video-with-python-3-opencv-3-on-osx.html"},{"tags":"Misc","title":"Manage project packages with virtualenv","text":"While developing two or more projects at the same time, it is unavoidable to switch among projects which may use the same python package of different version. In order to resolve the headache of package management, virtualenv is designed to create isolated python environments. Install virtualenv Open your terminal and execute pip3 install virtualenv virtualenvwrapper where virtualenvwrapper is a set of extension of virtualenv . Set environment variables In ~/.profile , add the lines below : export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3 export WORKON_HOME= $ HOME /.virtualenvs source /usr/local/bin/virtualenvwrapper.sh Followed by reloading ~/.profile : source ~/.profile Some examples of usage To create a new project environment named vision with python 3.4 support : $ mkvirtualenv -p /usr/local/bin/python3.4 vision In case we want to install ipython under vision environment : pip install ipython[notebook] To leave the environment of current project : deactivate To work on a existed project : workon project_name","url":"http://tsaith.github.io/manage-project-packages-with-virtualenv.html"},{"tags":"Machine learning","title":"Install OpenCV 3 for Python 3 on OSX","text":"First, install OpenCV 3 with homebrew as brew install opencv3 --with-python3 --with-contrib with --with-contrib flag, opencv_contrib packages containing algorithms that are either patented or in experimental development will also be installed. Second, set the environment variable PYTHONPATH to include the path of cv2.so which is a python binding to OpenCV. There are several ways to set PYTHONPATH , one way is to add the following line to ~/.profile . export PYTHONPATH= $ PYTHONPATH :/usr/local/Cellar/opencv3/3.0.0/lib/python3.4/site-packages Please note that the name of python directry depends on which python version you use, in my case is python3.4 . Be sure to execute source ~/.profile or restart your terminal to update PYTHONPATH . Now, let's check if our python 3 can import the module of OpenCV in the terminal. $ python3 Python 3.4 . 3 ( default , Jun 10 2015 , 19 : 57 : 30 ) [ GCC 4.2 . 1 Compatible Apple LLVM 6.0 ( clang - 600.0 . 57 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> import cv2 >>> cv2 . __version__ '3.0.0'","url":"http://tsaith.github.io/install-opencv-3-for-python-3-on-osx.html"},{"tags":"Machine learning","title":"A quick demo to recognizing hand-written digits with logistic regression","text":"This article will quickly demonstrate how to use the Logistic regression to recognize hand-written digits. The scikit-learn package is required in the example shown later. If you haven't installed it, please executing pip install scikit-learn and make sure that your IPython is ready to go. In this example, we want to fit a model of logistic regression with training data and labels. After that, the model can be used to predict the label corresponding to each instance of testing data. % matplotlib inline import matplotlib.pyplot as plt from sklearn import datasets , linear_model digits = datasets . load_digits () train_set_x = digits . data [: - 10 , :] # Training set x train_set_y = digits . target [: - 10 ] # Training set y (labels) test_set_x = digits . data [ - 10 :, :] # Test set x test_set_y = digits . target [ - 10 :] # Test set y (labels) test_set_images = digits . images [ - 10 :] # Test set images clf = linear_model . LogisticRegression () # Logistic regression clf . fit ( train_set_x , train_set_y ) # Fitting model predicted_y = clf . predict ( test_set_x ) print ( \"Predicted y = \" , predicted_y ) # Predicted labels print ( \"Test set y = \" , test_set_y ) # Expected labels plt . imshow ( test_set_images [ - 1 ], cmap = plt . cm . gray ) # Show the last image in the test set and the output is as As observed, the predicted labels are consistent with the expected ones. The last label is 8 as we see.","url":"http://tsaith.github.io/a-quick-demo-to-recognizing-hand-written-digits-with-logistic-regression.html"},{"tags":"Machine learning","title":"Automatically reload modules in IPython","text":"IPython provides an extension autoreload to reload the modules automatically. This is especially useful because we don't want to manually reload modules for testing when developing new functions. Just execute the following lines within IPython, all modules will be automatically reloaded before executing your code. % load_ext autoreload % autoreload 2","url":"http://tsaith.github.io/automatically-reload-modules-in-ipython.html"},{"tags":"Machine learning","title":"Visualize data with IPython","text":"This post will show how to visualize data with ipython. matplotlib install: pip install matplotlib With matplotlib , we are able to make inline plots by setting % matplotlib inline import matplotlib.pyplot as plt e.g. mpld3 install: pip install matplotlib With mpld3 , it is handy to zoom in/out or shift the plot through the lower left icons. To use mpld3, the following lines are required. import mpld3 mpld3 . enable_notebook () e.g.","url":"http://tsaith.github.io/visualize-data-with-ipython.html"},{"tags":"Machine learning","title":"Set up the python environment for computer vision","text":"Please install the following packages to set up the python environment for computer vision. Python The compiler of Python 3. brew install python3 Numpy A library for numerical calculation. pip install numpy Scipy A library for scientific computing. pip install scipy Matplotlib Powerful library to make plots. pip install matplotlib Ipython A browser-based notebook for interactive computing. pip install ipython[notebook] pip install pyzmq jinja2 tornado jsonschema mpld3 Ipdb IPython-enabled python debuger. pip install ipdb Scikit-learn Machine Learning library. pip install scikit-learn Scikit-image Image processing library. pip install scikit-image Pandas A library for data analysis. pip install pandas pytest A mature full-featured Python testing tool. pip install pytest","url":"http://tsaith.github.io/set-up-the-python-environment-for-computer-vision.html"},{"tags":"Web","title":"Create an IAM user for ElasticBeanstalk","text":"To use AWS ElasticBeanstalk , we have to create a IAM user first. After logging in AWS, go to IAM under Services . Click Create New Group under Groups and specify a group name (here, assumed as ElasticBeanstalkFullAccess ). Attach policy AWSElasticBeanstalkFullAccess to the group ElasticBeanstalkFullAccess . Click Create New Users under Users to create a new user supposed to use ElasticBeanstalk. During the process, it will prompt you to download security credentials composed by AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY . Under Users , add the user to the group ElasticBeanstalkFullAccess . From now on, you should be able to use ElasticBeanstalk with the security credentials downloaded.","url":"http://tsaith.github.io/create-an-iam-user-for-elasticbeanstalk.html"},{"tags":"Web","title":"Set up a postgres-backed rails app with ElasticBeanstalk","text":"This article will describe the way I set up a Rails app with ElasticBeanstalk and PostgresSQL. Here Rails 4.1 based on Puma 2.10.2 and Nginx 1.6.2 is demonstrated. Install ElasticBeanstalk CLI AWS provides both Management Console and EB CLI to work with ElasticBeanstalk. The CLI requires python and is easier to perform some features of ElasticBeanstalk. pip install awsebcli Create an IAM user ElasticBeanstalk will require an IAM user to create app environment. In case you have no idea how to create an IAM user, please view this post . Initialize a git repository Here agileorder is the name of my app. $ cd agileorder $ git init $ git add -A $ git commit -m \"Initial commit\" Initialize EB environment $ eb init Select a default region 1 ) us-east-1 : US East ( N. Virginia ) 2 ) us-west-1 : US West ( N. California ) 3 ) us-west-2 : US West ( Oregon ) 4 ) eu-west-1 : EU ( Ireland ) 5 ) eu-central-1 : EU ( Frankfurt ) 6 ) ap-southeast-1 : Asia Pacific ( Singapore ) 7 ) ap-southeast-2 : Asia Pacific ( Sydney ) 8 ) ap-northeast-1 : Asia Pacific ( Tokyo ) 9 ) sa-east-1 : South America ( Sao Paulo ) ( default is 3 ) : 8 Select an application to use 1 ) [ Create new Application ] ( default is 1 ) : 1 Enter Application Name: agileorder It appears you are using Ruby. Is this correct? ( y/n ) : y Select a platform version. 1 ) Ruby 2.2 ( Puma ) 2 ) Ruby 2.1 ( Puma ) 3 ) Ruby 2.0 ( Puma ) 4 ) Ruby 2.2 ( Passenger Standalone ) 5 ) Ruby 2.1 ( Passenger Standalone ) 6 ) Ruby 2.0 ( Passenger Standalone ) 7 ) Ruby 1.9.3 ( default is 1 ) : 2 Do you want to set up SSH for your instances? ( y/n ) : n Please note that eb init will add .elasticbeanstalk to the .gitignore . Be sure to commit .gitignore once again. $ git add .gitignore $ git commit -m \"Update .gitignore\" Configure EB to install postgresql-devel Under project directory, create .ebextensions/packages.config with following content. {% codeblock .ebextensions/packages.config lang:yaml %} packages: yum: postgresql93-devel: [] Then add the .ebextensions to repository git add .ebextensions git commit -m \"Add .ebextensions\" Create environment $ eb create agileorder-env After waiting for a while, the last part of output messages are shown as INFO : Application available at agileorder - env - jmcrf7dbdr . elasticbeanstalk . com . ERROR : Create environment operation is complete , but with errors . For more information , see troubleshooting documentation . INFO : Adding instance 'i-72db7287' to your environment . After checking logs, I figured out the errors come from the missing environment variables used in my app. Set up environment variables Under Software Configuration of Elastic Beanstalk of AWS Management Console , add essential environments used in app like SECRET_KEY_BASE , SENTRY_DSN , ...etc. Create a RDS instance Under Data Tier of Elastic Beanstalk of AWS Management Console , create a new RDS database and set the DB engine to postgres . After setting Master Username and Master Password , then click Save , environment variables will have been added to EB environment automatically. Configure database.yml to work with RDS instance Under project directory, modify the database.yml as config/database.yml: ... skip the parts of development and test modes ... production : adapter : postgresql encoding : unicode database : <%= ENV['RDS_DB_NAME'] %> username : <%= ENV['RDS_USERNAME'] %> password : <%= ENV['RDS_PASSWORD'] %> host : <%= ENV['RDS_HOSTNAME'] %> port : <%= ENV['RDS_PORT'] %> Commit the database.yml to repository git add -A git commit -m \"Update database.yml\" Finally, deploy the app to AWS. eb deploy To open the app URL in a browser, simply execute eb open","url":"http://tsaith.github.io/set-up-a-postgres-backed-rails-app-with-elasticbeanstalk.html"},{"tags":"Web","title":"Wait for Ajax with Capybara Automatically","text":"While writing feature tests involved in Ajax, we have to resolve race condition from time to time. Let's see the following code as an example. spec/features/admin_deletes_product_spec.rb: require 'spec_helper.rb' feature \"Admin deletes product category\" , { js : true } do before { page . driver . allow_url ( \"fonts.googleapis.com\" ) } after { clear_email } scenario \"when the action is successful\" do category = Fabricate ( :product_category ) product = Fabricate ( :product , category : category ) cloud = Fabricate ( :admin ) sign_in ( cloud ) visit admin_products_path find ( \"a[id='delete_product_ #{ product . id } ']\" ) . click # Without this line, there will be a race condition between deleting product and database query wait_for_ajax expect ( Product . count ) . to eq 0 end end where the function wait_for_ajax is used to make sure the product has been deleted before querying the count of products in database. spec/support/wait_for_ajax.rb: module WaitForAjax def wait_for_ajax Timeout . timeout ( Capybara . default_wait_time ) do loop until finished_all_ajax_requests? end end def finished_all_ajax_requests? page . evaluate_script ( 'jQuery.active' ) . zero? end end More discussion about this issue can be found in Thoughtbot's post .","url":"http://tsaith.github.io/wait-for-ajax-with-capybara-automatically.html"},{"tags":"Misc","title":"Create a user account to deploy production on ubuntu","text":"On production server, it is a good practice to create a user account (named deployer ) which is supposed to take care jobs of deployment. The steps are described as following. Log in the server as root via ssh ssh SERVER_IP Add new user named deployer adduser deployer Add deployer to group sudo gpasswd -a deployer sudo Switch from root to deployer su -l deployer Create .ssh directory and set proper access permission mkdir ~/.ssh chmod 700 ~/.ssh Copy the content of id_rsa.pub and paste it to authorized_keys On local computer: cat ~/.ssh/id_rsa.pub | pbcopy On remote server: vi ~/.ssh/authorized_keys and paste the content of public key. Set proper access permission on authorized_keys chmod 600 .ssh/authorized_keys Return to root exit Disable root login through SSH vi /etc/ssh/sshd_config and modify the line of PermitRootLogin as PermitRootLogin no Restart SSH service ssh restart Open a new terminal on local computer and log in the server as deployer ssh deployer@SERVER_IP Let deployer can use sudo without password sudo visudo Add following line at the end of file deployer ALL=(ALL) NOPASSWD: ALL Execute Ctrl-x -> Y -> Enter to save and exit file.","url":"http://tsaith.github.io/create-a-user-account-to-deploy-production-on-ubuntu.html"},{"tags":"Web","title":"Install rbenv and rails on ubuntu","text":"This article will describe how to install rbenv , rails and some useful libraries on a production server of ubuntu . Assuming that, on a fresh ubuntu, we have just built and logged in with a user account named deployer . Update apt-get sudo apt-get update Install gcc, make and curl sudo apt-get install gcc make curl Install git sudo apt-get install git git-core Configure git git config --global user.name \"Your Name\" git config --global user.email \"Your Email Address\" git config --global core.editor vi git config --global color.ui true git config --global color.branch auto git config --global color.diff auto git config --global color.status auto Install libraries required by rbenv sudo apt-get install autoconf bison build-essential libssl-dev libyaml-dev libreadline6-dev zlib1g-dev libncurses5-dev libffi-dev libgdbm3 libgdbm-dev Install rbenv and the ruby versions builder git clone git://github.com/sstephenson/rbenv.git .rbenv echo 'export PATH=\" $ HOME /.rbenv/bin: $ PATH \"' >> ~/.bashrc echo 'eval \" $( rbenv init - ) \"' >> ~/.bashrc git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build echo 'export PATH=\" $ HOME /.rbenv/plugins/ruby-build/bin: $ PATH \"' >> ~/.bashrc git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash git clone https://github.com/ianheggie/rbenv-binstubs.git ~/.rbenv/plugins/rbenv-binstubs Add path for binstubs echo 'PATH=\"./bin: $ PATH \"' >> ~/.bashrc Relogin the server exit ssh deployer@SERVER_IP Install Ruby version rbenv install 2.1.5 rbenv global 2.1.5 Install bundler gem install bundler Install gems without documents echo 'gem: --no-rdoc --no-ri' >> ~/.gemrc Install rails gem install rails -v 4.1.1 Install Node.js (javascript runtime) which is required to compile assests of rails sudo apt-add-repository -y ppa:chris-lea/node.js sudo apt-get -y update sudo apt-get -y install nodejs Install qt lib for capybara-webkit [https://github.com/thoughtbot/capybara-webkit] sudo apt-get install libqt4-dev Install ImageMagick sudo apt-get install imagemagick Install PostgreSQL sudo apt-get install postgresql libpq-dev Execute the following command under project directory to make binstubs work bundle install --binstubs .bundle/bin Set environment variables sudo vi /etc/environment and add the following lines: RAILS_ENV=production RACK_ENV=production Create a new user named deployer as superuser within PostgreSQL sudo su -l postgres createuser deployer --pwprompt psql ALTER USER deployer WITH SUPERUSER; \\q exit","url":"http://tsaith.github.io/install-rbenv-and-rails-on-ubuntu.html"},{"tags":"Web","title":"Install Sidekiq and Redis on Ubuntu","text":"Sidekiq is a efficient tool to take care backgroud jobs of rails and reuired the support of Redis . Switch to root sudo su -l Install Redis apt-get install redis-server service redis-server restart Write a init script for Sidekiq Create /etc/init.d/sidekiq with following content: /etc/init.d/sidekiq: #!/bin/sh # File: /etc/init.d/sidekiq ### BEGIN INIT INFO # Provides: unicorn # Required-Start: $local_fs $remote_fs $network $syslog # Required-Stop: $local_fs $remote_fs $network $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: starts the sidekiq # Description: starts sidekiq ### END INIT INFO # Feel free to change any of the following variables for your app: # Set user USER = deployer # Set app name APP_NAME = myflix # R.eplace [PATH_TO_RAILS_ROOT_FOLDER] with your application's path. APP_ROOT = /home/ $USER /apps/ $APP_NAME /current # Set the environment. This can be changed to staging or development for staging # servers. RAILS_ENV = production PID_FILE = $APP_ROOT /tmp/sidekiq.pid LOG_FILE = $APP_ROOT /log/sidekiq.log # A simple description for service output. DESC = \"Sidekiq - $RAILS_ENV \" SIDEKIQ = \"/home/ $USER /.rbenv/shims/sidekiq\" SIDEKIQ_OPTS = \"--pidfile $PID_FILE --logfile $LOG_FILE --environment $RAILS_ENV --daemon\" CMD = \"cd $APP_ROOT ; $SIDEKIQ $SIDEKIQ_OPTS \" REMOVE_PID_FILE = \"rm -f $PID_FILE \" # Give your upgrade action a timeout of 60 seconds. TIMEOUT = 60 # Store the action that we should take from the service command's first # argument (e.g. start, stop, upgrade). action = \" $1 \" # Make sure the script exits if any variables are unset. This is short for # set -o nounset. set -u # Set the location of the old pid. The old pid is the process that is getting # replaced. old_pid = \" $PID_FILE .oldbin\" # Make sure the APP_ROOT is actually a folder that exists. An error message from # the cd command will be displayed if it fails. cd $APP_ROOT || exit 1 # A function to send a signal to the current unicorn master process. sig () { test -s \" $PID_FILE \" && kill - $1 ` cat $PID_FILE ` } # Send a signal to the old process. oldsig () { test -s $old_pid && kill - $1 ` cat $old_pid ` } # A switch for handling the possible actions to take on the unicorn process. case $action in # Start the process by testing if it's there (sig 0), failing if it is, # otherwise running the command as specified above. start ) sig 0 && echo > & 2 \" $DESC is already running\" && exit 0 su - $USER -c \" $CMD \" ;; # Graceful shutdown. Send QUIT signal to the process. Requests will be # completed before the processes are terminated. stop ) sig QUIT && echo \"Stopping $DESC \" exit 0 su - $USER -c \" $REMOVE_PID_FILE \" echo > & 2 \"Not running\" ;; # Quick shutdown - kills all workers immediately. force-stop ) sig TERM && echo \"Force-stopping $DESC \" && exit 0 echo > & 2 \"Not running\" ;; # Graceful shutdown and then start. restart ) sig QUIT && echo \"Restarting $DESC \" && sleep 2 \\ && su - $USER -c \" $CMD \" && exit 0 echo > & 2 \"Couldn't restart.\" ;; # Reloads config file (unicorn.rb) and gracefully restarts all workers. This # command won't pick up application code changes if you have `preload_app # true` in your unicorn.rb config file. reload ) sig HUP && echo \"Reloading configuration for $DESC \" && exit 0 echo > & 2 \"Couldn't reload configuration.\" ;; # Re-execute the running binary, then gracefully shutdown old process. This # command allows you to have zero-downtime deployments. The application may # spin for a minute, but at least the user doesn't get a 500 error page or # the like. Unicorn interprets the USR2 signal as a request to start a new # master process and phase out the old worker processes. If the upgrade fails # for some reason, a new process is started. upgrade ) if sig USR2 && echo \"Upgrading $DESC \" && sleep 10 \\ && sig 0 && oldsig QUIT then n = $TIMEOUT while test -s $old_pid && test $n -ge 0 do printf '.' && sleep 1 && n = $(( $n - 1 )) done echo if test $n -lt 0 && test -s $old_pid then echo > & 2 \" $old_pid still exists after $TIMEOUT seconds\" exit 1 fi exit 0 fi echo > & 2 \"Couldn't upgrade, starting 'su - $USER -c \\\" $CMD \\\"' instead\" su - $USER -c \" $CMD \" ;; # A basic status checker. Just checks if the master process is responding to # the `kill` command. status ) sig 0 && echo > & 2 \" $DESC is running.\" && exit 0 echo > & 2 \" $DESC is not running.\" ;; # Reopen all logs owned by the master and all workers. reopen-logs ) sig USR1 ;; # Any other action gets the usage message. * ) # Usage echo > & 2 \"Usage: $0 <start|stop|restart|reload|upgrade|force-stop|reopen-logs>\" exit 1 ;; esac and execute the commands below. chmod 755 sidekiq update-rc.d sidekiq defaults 99 service sidekiq restart","url":"http://tsaith.github.io/install-sidekiq-and-redis-on-ubuntu.html"},{"tags":"Web","title":"Setting up a rails production server on Ubuntu","text":"In this article, the steps to set up a rails production server based on DigitalOcean VPS of Ubuntu 14.04 x64 are recorded as following. Create a user account to deploy production Install Rbenv and Rails Setting up Nginx+Unicorn Install Sidekiq and Redis Setting up Logrotate","url":"http://tsaith.github.io/setting-up-a-rails-production-server-on-ubuntu.html"},{"tags":"Web","title":"Setting up logrotate for production server","text":"This article will demonstrate how to use logrotate to maintain log files of rails. Switch to root sudo su -l Define a file to maintain log files of rails Assuming your app name is myflix , create /etc/logrotate.d/rails with following content: /etc/logrotate.d/rails: /home/deployer/apps/myflix/current/log/*.log { daily missingok rotate 7 compress delaycompress notifempty copytruncate sharedscripts postrotate service sidekiq restart service unicorn restart endscript } You may execute the command below for testing logrotate -vf /etc/logrotate.conf","url":"http://tsaith.github.io/setting-up-logrotate-for-production-server.html"},{"tags":"Web","title":"Setting up Nginx+Unicorn production server","text":"This article will describe how to install and configure Nginx with Unicorn to build a concurrent rails server based on Ubuntu. Assume that we have logged in with a user account named deployer . Install Unicorn Adding the following line to your Gemfile and execute bundle install . gem 'unicorn' Switch to root sudo su -l Write a init script for Unicorn Asuming the name of your app is myflix , create /etc/init.d/unicorn with the following content: /etc/init.d/unicorn: #!/bin/sh # File: /etc/init.d/unicorn ### BEGIN INIT INFO # Provides: unicorn # Required-Start: $local_fs $remote_fs $network $syslog # Required-Stop: $local_fs $remote_fs $network $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: starts the unicorn web server # Description: starts unicorn ### END INIT INFO # Feel free to change any of the following variables for your app: # Set user USER = deployer # Set app name APP_NAME = myflix # Replace [PATH_TO_RAILS_ROOT_FOLDER] with your application's path. APP_ROOT = /home/ $USER /apps/ $APP_NAME /current # Set the environment. This can be changed to staging or development for staging # servers. RAILS_ENV = production # This should match the pid setting in $APP_ROOT/config/unicorn.rb. PID_FILE = $APP_ROOT /tmp/unicorn.pid # A simple description for service output. DESC = \"Unicorn app - $RAILS_ENV \" # If you're using rbenv, you may need to use the following setup to get things # working properly: RBENV_RUBY_VERSION = ` cat $APP_ROOT /.ruby-version ` RBENV_ROOT = \"/home/ $USER /.rbenv\" RBENV = \" $RBENV_ROOT /bin/rbenv\" PATH = \" $RBENV_ROOT /bin: $PATH \" SET_PATH = \"cd $APP_ROOT && $RBENV rehash && $RBENV local $RBENV_RUBY_VERSION \" # Unicorn can be run using `bundle exec unicorn` or `bin/unicorn`. UNICORN = \" $RBENV_ROOT /shims/unicorn\" # Execute the unicorn executable as a daemon, with the appropriate configuration # and in the appropriate environment. UNICORN_OPTS = \"-c $APP_ROOT /config/unicorn.rb -E $RAILS_ENV -D\" CMD = \" $UNICORN $UNICORN_OPTS \" # Give your upgrade action a timeout of 60 seconds. TIMEOUT = 60 # Store the action that we should take from the service command's first # argument (e.g. start, stop, upgrade). action = \" $1 \" # Make sure the script exits if any variables are unset. This is short for # set -o nounset. set -u # Set the location of the old pid. The old pid is the process that is getting # replaced. old_pid = \" $PID_FILE .oldbin\" # Make sure the APP_ROOT is actually a folder that exists. An error message from # the cd command will be displayed if it fails. cd $APP_ROOT || exit 1 # A function to send a signal to the current unicorn master process. sig () { test -s \" $PID_FILE \" && kill - $1 ` cat $PID_FILE ` } # Send a signal to the old process. oldsig () { test -s $old_pid && kill - $1 ` cat $old_pid ` } # A switch for handling the possible actions to take on the unicorn process. case $action in # Start the process by testing if it's there (sig 0), failing if it is, # otherwise running the command as specified above. start ) sig 0 && echo > & 2 \" $DESC is already running\" && exit 0 su - $USER -c \" $CMD \" ;; # Graceful shutdown. Send QUIT signal to the process. Requests will be # completed before the processes are terminated. stop ) sig QUIT && echo \"Stopping $DESC \" exit 0 echo > & 2 \"Not running\" ;; # Quick shutdown - kills all workers immediately. force-stop ) sig TERM && echo \"Force-stopping $DESC \" && exit 0 echo > & 2 \"Not running\" ;; # Graceful shutdown and then start. restart ) sig QUIT && echo \"Restarting $DESC \" && sleep 2 \\ && su - $USER -c \" $CMD \" && exit 0 echo > & 2 \"Couldn't restart.\" ;; # Reloads config file (unicorn.rb) and gracefully restarts all workers. This # command won't pick up application code changes if you have `preload_app # true` in your unicorn.rb config file. reload ) sig HUP && echo \"Reloading configuration for $DESC \" && exit 0 echo > & 2 \"Couldn't reload configuration.\" ;; # Re-execute the running binary, then gracefully shutdown old process. This # command allows you to have zero-downtime deployments. The application may # spin for a minute, but at least the user doesn't get a 500 error page or # the like. Unicorn interprets the USR2 signal as a request to start a new # master process and phase out the old worker processes. If the upgrade fails # for some reason, a new process is started. upgrade ) if sig USR2 && echo \"Upgrading $DESC \" && sleep 10 \\ && sig 0 && oldsig QUIT then n = $TIMEOUT while test -s $old_pid && test $n -ge 0 do printf '.' && sleep 1 && n = $(( $n - 1 )) done echo if test $n -lt 0 && test -s $old_pid then echo > & 2 \" $old_pid still exists after $TIMEOUT seconds\" exit 1 fi exit 0 fi echo > & 2 \"Couldn't upgrade, starting 'su - $USER -c \\\" $CMD \\\"' instead\" su - $USER -c \" $CMD \" ;; # A basic status checker. Just checks if the master process is responding to # the `kill` command. status ) sig 0 && echo > & 2 \" $DESC is running.\" && exit 0 echo > & 2 \" $DESC is not running.\" ;; # Reopen all logs owned by the master and all workers. reopen-logs ) sig USR1 ;; # Any other action gets the usage message. * ) # Usage echo > & 2 \"Usage: $0 <start|stop|restart|reload|upgrade|force-stop|reopen-logs>\" exit 1 ;; esac Then, execute chmod +x /etc/init.d/unicorn update-rc.d unicorn defaults service unicorn restart Prepare the configuration file of Unicorn under project directory Create config/unicorn.rb with content as config/unicorn.rb: # Set the current app's path for later reference. Rails.root isn't available at # this point, so we have to point up a directory. app_path = File . expand_path ( File . dirname ( __FILE__ ) + '/..' ) # The number of worker processes you have here should equal the number of CPU cores your server has. worker_processes ( ENV [ 'RAILS_ENV' ] == 'production' ? 2 : 1 ) # You can listen on a port or a socket. Listening on a socket is good in a # production environment, but listening on a port can be useful for local # debugging purposes. listen app_path + '/tmp/unicorn.sock' , backlog : 64 # For development, you may want to listen on port 3000 so that you can make sure # your unicorn.rb file is soundly configured. listen ( 3000 , backlog : 64 ) if ENV [ 'RAILS_ENV' ] == 'development' # After the timeout is exhausted, the unicorn worker will be killed and a new # one brought up in its place. Adjust this to your application's needs. The # default timeout is 60. Anything under 3 seconds won't work properly. timeout 60 # Set the working directory of this unicorn instance. working_directory app_path # Set the location of the unicorn pid file. This should match what we put in the # unicorn init script later. pid app_path + '/tmp/unicorn.pid' # You should define your stderr and stdout here. If you don't, stderr defaults # to /dev/null and you'll lose any error logging when in daemon mode. stderr_path app_path + '/log/unicorn.log' stdout_path app_path + '/log/unicorn.log' # Load the app up before forking. preload_app true # Garbage collection settings. GC . respond_to? ( :copy_on_write_friendly = ) && GC . copy_on_write_friendly = true # If using ActiveRecord, disconnect (from the database) before forking. before_fork do | server , worker | defined? ( ActiveRecord :: Base ) && ActiveRecord :: Base . connection . disconnect! end # After forking, restore your ActiveRecord connection. after_fork do | server , worker | defined? ( ActiveRecord :: Base ) && ActiveRecord :: Base . establish_connection end Install and configure Nginx apt-get install nginx Edit /etc/nginx/nginx.conf as below /etc/nginx/nginx.conf: # Run nginx as www-data. user www-data ; # One worker process per CPU core is a good guideline. worker_processes 1 ; pid /var/run/nginx.pid ; # For a single core server, 1024 is a good starting point. Use `ulimit -n` to # determine if your server can handle more. events { worker_connections 1024 ; } http { ## # Basic Settings ## sendfile on ; tcp_nopush on ; tcp_nodelay off ; keepalive_timeout 65 ; types_hash_max_size 2048 ; server_tokens off ; include /etc/nginx/mime.types ; default_type application/octet-stream ; ## # Logging Settings ## access_log /var/log/nginx/access.log ; error_log /var/log/nginx/error.log ; ## # Gzip Settings ## gzip on ; gzip_disable \"msie6\" ; gzip_http_version 1.1 ; gzip_proxied any ; gzip_min_length 500 ; gzip_types text/plain text/xml text/css text/comma-separated-values text/javascript application/x-javascript application/atom+xml ; ## # Unicorn Rails ## # The socket here must match the socket path that you set up in unicorn.rb. upstream unicorn { server unix:/home/deployer/apps/myflix/current/tmp/unicorn.sock fail_timeout = 0 ; } ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf ; include /etc/nginx/sites-enabled/* ; } Create /etc/nginx/sites-available/myflix with content: /etc/nginx/sites-available/myflix: server { listen 80 ; server_name myflix.com ; # Set server name keepalive_timeout 300 ; client_max_body_size 4G ; root /home/deployer/apps/myflix/current/public ; # Set this to the public folder location of your Rails application. try_files $uri /index.html $uri .html $uri @unicorn ; location @unicorn { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_set_header Host $http_host ; proxy_set_header X-Forwarded_Proto $scheme ; proxy_redirect off ; # This passes requests to unicorn, as defined in /etc/nginx/nginx.conf proxy_pass http://unicorn ; proxy_read_timeout 300s ; proxy_send_timeout 300s ; } # You can override error pages by redirecting the requests to a file in your # application's public folder, if you so desire: error_page 500 502 503 504 /500.html ; location = /500.html { root /home/deployer/apps/myflix/current/public ; } } Finally, execute the following commands: cd /etc/nginx/sites-enabled rm default ln -s ../sites-available/myflix myflix service nginx restart","url":"http://tsaith.github.io/setting-up-nginxunicorn-production-server.html"},{"tags":"Web","title":"Deploy production with Capistrano","text":"This article will describe how to deploy production with Capistrano . The official site provides useful explanations on the usage and structure of capistrano. Here we assume that you are already able to login your production server with SSH key. Installation Add the lines to Gemfile: Gemfile: gem 'capistrano-rails' , '1.1.2' gem 'capistrano-rbenv' , '2.0.3' , require : false Install and initialize capistrano: bundle install cap install Add the followings lines to Capfile . require 'capistrano/setup' require 'capistrano/deploy' require 'capistrano/rbenv' require 'capistrano/bundler' require 'capistrano/rails/migrations' require 'capistrano/rails/assets' Dir . glob ( 'lib/capistrano/tasks/*.rake' ) . each { | r | import r } Configuration Set up global configuration in config/deploy.rb as following sample. config/deploy.rb: # config valid only for current version of Capistrano lock '3.4.0' set :application , 'YOUR_APP_Name' set :domain , \" #{ fetch ( :application ) } .com\" set :user , \"deployer\" set :repo_url , \"git@bitbucket.org:YOUR_ACCOUNT_NAME/ #{ fetch ( :application ) } .git\" set :deploy_to , \"/home/deployer/apps/ #{ fetch ( :application ) } \" set :current_path , \" #{ fetch ( :deploy_to ) } /current\" set :shared_path , \" #{ fetch ( :deploy_to ) } /shared\" set :releases_path , \" #{ fetch ( :deploy_to ) } /releases\" set :default_env , { path : \"~/.rbenv/shims:~/.rbenv/bin:$PATH\" } set :rbenv_ruby , '2.1.5' set :deploy_via , :remote_cache set :linked_files , fetch ( :linked_files , [] ) . push ( 'config/application.yml' , 'config/database.yml' , 'config/secrets.yml' ) set :linked_dirs , fetch ( :linked_dirs , [] ) . push ( 'log' , 'tmp' ) Next, set up the IP of your production server in config/deploy/production.rb : config/deploy/production.rb: server '162.233.120.172' , user : 'deployer' , roles : %w{web app db} Be sure that db is added for database migration will be executed. Start to deploy All you have to do is execute this command: cap production deploy List all tasks To view all available tasks in capistrano: cap -T Define your own tasks You can write your own tasks and put them under lib/capistrano/tasks/ . For example, assume we have wrote a task named access_check.rake with following content: lib/capistrano/tasks/access_check.rake: desc \"Check that we can access everything\" task :check_write_permissions do on roles ( :all ) do | host | if test ( \"[ -w #{ fetch ( :deploy_to ) } ]\" ) info \" #{ fetch ( :deploy_to ) } is writable on #{ host } \" else error \" #{ fetch ( :deploy_to ) } is not writable on #{ host } \" end end end Now, we can check if we have enough writing permissions on the production server by executing: cap production check_write_permissions","url":"http://tsaith.github.io/deploy-production-with-capistrano.html"},{"tags":"Web","title":"Is your site accessible from China?","text":"The following sites provide conivient tools to detect if your site is blocked from the firewall of China. WebSitePulse GreatFire","url":"http://tsaith.github.io/is-your-site-accessible-from-china.html"},{"tags":"Misc","title":"Vi-mode in command-line and Rails Console","text":"Since both command-line and rails console treat characters with readline , we can add the line below in ~/.inputrc set editing-mode vi to switch from the default emacs-mode to vi-mode .","url":"http://tsaith.github.io/vi-mode-in-command-line-and-rails-console.html"},{"tags":"Web","title":"Custom domain for your app on Heroku","text":"First of all, apply a domain from any DNS provider like Godaddy . To add a domain to your app, please execute the following command under the project directory. heroku domains:add www.example.com To remove the domain from your app, please execute heroku domains:remove www.example.com","url":"http://tsaith.github.io/custom-domain-for-your-app-on-heroku.html"},{"tags":"Web","title":"Adding google analytics to octopress","text":"Go to Google Analytics to get the tracking id. Then, set the valud of google_analytics_tracking_id in the _config.yml of Octopress. _config.yml: # Google Analytics google_analytics_tracking_id: UA-59891323-1 使用 Github Pages In case you use Github Pages for Octopress, please also add one line in the source/_includes/google_analytics.html as below. source/_includes/google_analytics.html: {% if site.google_analytics_tracking_id %} <script type= \"text/javascript\" > var _gaq = _gaq || []; _gaq . push ([ '_setAccount' , '{{ site.google_analytics_tracking_id }}' ]); _gaq . push ([ '_setDomainName' , 'github.io' ]); // add this line for Github Pages _gaq . push ([ '_trackPageview' ]); ( function () { var ga = document . createElement ( 'script' ); ga . type = 'text/javascript' ; ga . async = true ; ga . src = ( 'https:' == document . location . protocol ? 'https://ssl' : 'http://www' ) + '.google-analytics.com/ga.js' ; var s = document . getElementsByTagName ( 'script' )[ 0 ]; s . parentNode . insertBefore ( ga , s ); })(); </script> {% endif %} After publishing above settings, you are ready to view the traffic status in google analytics.","url":"http://tsaith.github.io/adding-google-analytics-to-octopress.html"},{"tags":"Web","title":"在 Rails 中安裝與設定 Bootstrap","text":"Bootstrap 是目前相當受歡迎的前端開發框架，提供了許多現成的元件，幫助人們可以快速設計網站頁面， 此外還提供 Responsive Web Design 的功能， 讓網頁可以自動在不同尺寸的裝置上縮放; 以下將介紹如何在 Rails 中進行 Bootstrap 的安裝與設定。 安裝套件 在 Gemfile 中加入 gem 'bootstrap-sass' gem 'autoprefixer-rails' gem 'sass-rails' gem 'sprockets-rails' , :require => 'sprockets/railtie' 然後執行 bundle install 安裝套件。 載入 Bootstrap 函式庫 進入 app/assets/stylesheets/， 將原有的 application.css 移除， 然後新增檔案 application.css.sass 並加入以下的內容 app/assets/stylesheets/application.css.sass: @import \"bootstrap-sprockets\" @import \"bootstrap\" 請注意 bootstrap-sprockets 的載入順序必須在 bootstrap 之前。 編輯 app/assets/javascripts/application.js ， 在檔案中加入 //= require bootstrap-sprockets 如下 app/assets/javascripts/application.js: // This is a manifest file that'll be compiled into application.js, which will include all the files // listed below. // // Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts, // or vendor/assets/javascripts of plugins, if any, can be referenced here using a relative path. // // It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the // compiled file. // // Read Sprockets README (https://github.com/sstephenson/sprockets#sprockets-directives) for details // about supported directives. // //= require jquery //= require jquery_ujs //= require turbolinks //= require bootstrap-sprockets //= require_tree . 最後，請確定在 app/views/layouts/application.html.haml 裡面有個別載入 Stylesheet 和 Javascript app/views/layouts/application.html.haml: !!! 5 %html ( lang= \"en-US\" ) %head %title Bed & Breakfast %meta ( charset= \"UTF-8\" ) %meta ( name= \"viewport\" content= \"width=device-width, initial-scale=1.0\" ) = csrf_meta_tag -# 載入 Stylesheet = stylesheet_link_tag \"application\" , :media => \"all\" , 'data-turbolinks-track' => true -# 載入 Javascript = javascript_include_tag \"application\" , 'data-turbolinks-track' => true %body %header = render 'shared/header' %section .content.clearfix = render 'shared/messages' = yield %footer &copy 2015 Bed & Breakfast 完成以上的設定後，我們就可以開始使用 Bootstrap 的各種功能來進行網頁的設計。","url":"http://tsaith.github.io/zai-rails-zhong-an-zhuang-yu-she-ding-bootstrap.html"},{"tags":"Web","title":"在 Rails 中處理信用卡付款失敗","text":"這篇文章將以 Stripe 金流服務為例， 示範當付款失敗時，如何暫停使用者帳號。 安裝套件 在 Gemfile 裡面加入 gem 'stripe_event' 然後執行 bundle install 。 新增 active 欄位 在 users table 中新增 active 欄位， 預設值為 true ，如下 db/schema.rb: create_table \"users\" , force : true do | t | t . string \"full_name\" t . string \"email\" t . string \"password_digest\" t . string \"slug\" t . string \"token\" t . boolean \"admin\" t . string \"customer_token\" t . datetime \"created_at\" t . datetime \"updated_at\" t . boolean \"active\" , default : true # 新增此欄位 end 設定 initializer 在 config/initializers/stripe.rb 裡面敘述付款失敗時將使帳號無效 config/initializers/stripe.rb: Stripe . api_key = ENV [ 'STRIPE_SECRET_KEY' ] StripeEvent . configure do | events | # 付款成功 events . subscribe 'charge.succeeded' do | event | user = User . where ( customer_token : event . data . object . customer ) . first Payment . create ( user : user , amount : event . data . object . amount , reference_id : event . data . object . id ) end # 付款失敗 events . subscribe 'charge.failed' do | event | user = User . where ( customer_token : event . data . object . customer ) . first user . deactivate! # 使帳號無效 end end 修改 Model 和 Controller 在 User model 裡面，新增 deactivate! 方法 app/models/user.rb: class User < ActiveRecord :: Base ... 省略程式碼 ... def deactivate! self . update_column ( :active , false ) end end 在處理登入的 SessionController 裡面， 判斷使用者帳號是否有效，如下 app/controllers/sessions_controller.rb: class SessionsController < ApplicationController ... 省略程式碼 ... def create user = User . where ( email : params [ :email ] ) . first if user && user . authenticate ( params [ :password ] ) # 判斷帳號是否有效 if user . active? session [ :user_id ] = user . id flash [ :success ] = \"Your've signed in, enjoy!\" redirect_to home_path else flash [ :success ] = \"Your account has been suspended, please contact customer service.\" redirect_to sign_in_path end else flash [ :danger ] = \"Invalid email or password.\" redirect_to sign_in_path end end end 設定 Stripe webhook requests 最後在 Stripe 的 Webhook Settings 新增欲接收 webhook requests 的 URL; 詳細的說明可以參考 先前的文章 。","url":"http://tsaith.github.io/zai-rails-zhong-chu-li-xin-yong-qia-fu-kuan-shi-bai.html"},{"tags":"Web","title":"查看交易記錄的後台功能","text":"這裡將以 Stripe 金流服務為例， 介紹如何為網站後台新增查看交易記錄的功能。 安裝套件 在 Gemfile 裡面加入 gem 'stripe_event' 然後執行 bundle install 。 設定 routes 在 routes.rb 加入 config/routes.rb: namespace :admin do resources :payments , only : [ :index ] end mount StripeEvent :: Engine , at : '/stripe_events' 新增 payments table 在資料庫中新增 payments table 如下 db/schema.rb: create_table \"payments\" , force : true do | t | t . integer \"user_id\" t . integer \"amount\" t . string \"reference_id\" end 設定 initializer 在 config/initializers/stripe.rb 裡面處理付款成功的事件 config/initializers/stripe.rb: Stripe . api_key = ENV [ 'STRIPE_SECRET_KEY' ] StripeEvent . configure do | events | # 付款成功 events . subscribe 'charge.succeeded' do | event | user = User . where ( customer_token : event . data . object . customer ) . first # 產生交易記錄 Payment . create ( user : user , amount : event . data . object . amount , reference_id : event . data . object . id ) end end 倘若不清楚如何使用 Stripe 提供交易機制， 可以參考 這裡 。 新增 Model/View/Controller 新增 Payment model app/models/payment.rb: class Payment < ActiveRecord :: Base belongs_to :user end 新增 PaymentsController app/controllers/admin/payments_controller.rb: class Admin :: PaymentsController < AdminsController def index @payments = Payment . all end end 新增 view 以查看交易記錄，如下 app/views/admin/payments/index.html.haml: %section .admin_payments .container .row .col-sm-10.col-sm-offset-1 %section .payment_history %ul .nav.nav-tabs %li .active = link_to \"Recent Payments\" , admin_payments_path %li = link_to \"Add a New Video\" , new_admin_video_path %table .table %thead %tr %th Name %th Email %th Amount %th Reference ID %tbody - @payments . each do | payment | %tr %td = payment . user . full_name %td = payment . user . email %td = \"$ #{ payment . amount / 100 . 0 } \" %td = payment . reference_id 設定 Stripe Webhooks 最後，在 Stripe 的 Webhook Settings 裡面， 新增要接收 webhook requests 的 URL; 例如，倘若我們的網站位址是 th-myflix.herokuapp.com， 那麼新增的 URL 即為 th-myflix.herokuapp.com/stripe_events 在本機開發時， 可以使用免費的 ngrok 服務產生 public 位址， 以接收 webhook requests 進行測試。","url":"http://tsaith.github.io/cha-kan-jiao-yi-ji-lu-de-hou-tai-gong-neng.html"},{"tags":"Web","title":"依照簽署方案進行收費","text":"假設我們現在想為網站開發收費機制， 使用者註冊後會立刻索取第一個月的服務費用， 之後每過一個月， 系統都會自動向客戶的信用卡帳戶請款。 下面將以 Stripe 金流服務為例， 敘述如何在 Rails 中實作這項功能。 設定 Plans 請先在 Stripe Plans 新增一個 ID 為 base 的收費方案，如下 新增 customer_token 然後在 Rails 的 users table 裡面， 新增 customer_token 欄位，如下 db/schema.rb: create_table \"users\" , force : true do | t | t . string \"full_name\" t . string \"email\" t . string \"password_digest\" t . string \"slug\" t . string \"token\" t . boolean \"admin\" t . string \"customer_token\" # 新增 customer_token t . boolean \"active\" , default : true t . datetime \"created_at\" t . datetime \"updated_at\" end 設定 Stripe API Key 在 config/initializers/stripe.rb， 裡面設定 Stripe 的 API Key config/initializers/stripe.rb: Stripe . api_key = ENV [ 'STRIPE_SECRET_KEY' ] 產生 Stripe customer 在處理註冊的 服務 裡面， 產生 Stripe customer， 並將 customer token 儲存下來 app/services/user_signup.rb: class UserSignup attr_reader :error_message def initialize ( user ) @user = user end def sign_up ( stripe_token ) if @user . valid? # 產生 Stripe customer customer = StripeWrapper :: Customer . create ( :user => @user , :card => stripe_token , :description => \"Sign up for #{ @user . email } \" ) if customer . successful? # 儲存 customer token @user . customer_token = customer . customer_token @user . save AppMailer . delay . send_welcome_email ( @user ) @status = :success self else @status = :failed @error_message = customer . error_message self end else @status = :failed @error_message = \"Invalid user information. Please check the errors below.\" self end end def successful? @status == :success end end class UserSignup attr_reader :error_message def initialize ( user ) @user = user end def sign_up ( stripe_token ) if @user . valid? # 產生 Stripe customer customer = StripeWrapper :: Customer . create ( :user => @user , :card => stripe_token , :description => \"Sign up for #{ @user . email } \" ) if customer . successful? @user . save AppMailer . delay . send_welcome_email ( @user ) @status = :success self else @status = :failed @error_message = customer . error_message self end else @status = :failed @error_message = \"Invalid user information. Please check the errors below.\" self end end def successful? @status == :success end end StripeWrapper 定義了產生 Stripe customer 的動作， 並且將預設方案設為 base app/models/stripe_wrapper.rb: module StripeWrapper class Customer attr_reader :response , :error_message def initialize ( options = {}) @response = options [ :response ] @error_message = options [ :error_message ] end def self . create ( options = {}) begin response = Stripe :: Customer . create ( :card => options [ :card ] , :plan => options [ :plan ] || \"base\" , # 預設為 base 方案 :email => options [ :user ]. email ) new ( response : response ) rescue Stripe :: CardError => e new ( error_message : e . message ) end end def successful? response . present? end def customer_token response . id end end end","url":"http://tsaith.github.io/yi-zhao-qian-shu-fang-an-jin-xing-shou-fei.html"},{"tags":"Web","title":"使用 Service Objects 編寫註冊服務","text":"開發專案時，我們常常會遇到一種情況， 隨著功能不斷地加入， Controller 也變得越來越肥胖; 例如，在下面的 create 方法中， 包含了使用者資料的檢驗、進行信用卡交易以及發送歡迎信件等動作。 app/controllers/users_controller.rb: class UsersController < ApplicationController ... 程式碼省略 ... def create @user = User . new ( user_params ) if @user . valid? # 檢驗使用者資料 # 信用卡交易 charge = StripeWrapper :: Charge . create ( :amount => 999 , # in cents :currency => \"usd\" , :card => params [ :stripeToken ] , :description => \"Sign up for #{ @user . email } \" ) if charge . successful? @user . save session [ :user_id ] = @user . id AppMailer . delay . send_welcome_email ( @user ) # 發送歡迎信件 flash [ :success ] = \"Thank you for registering with MyFlix.\" redirect_to home_path else flash [ :danger ] = charge . error_message render :new end else flash [ :danger ] = \"Invalid user information. Please check the errors below.\" render :new end end end 因為描述物件之間交互作用的邏輯， 並不適合放進單一模型中， 此時可以考慮使用 Service Objects 為 Controller 瘦身。 編寫註冊服務 在 app/services 目錄下， 新增檔案 user_signup.rb，加入註冊相關的動作 app/services/user_signup.rb: class UserSignup attr_reader :error_message def initialize ( user ) @user = user end def sign_up ( stripe_token ) if @user . valid? # 檢驗使用者資料 # 信用卡交易 charge = StripeWrapper :: Charge . create ( :amount => 999 , # in cents :currency => \"usd\" , :card => stripe_token , :description => \"Sign up for #{ @user . email } \" ) if charge . successful? @user . save AppMailer . delay . send_welcome_email ( @user ) # 發送歡迎信件 @status = :success self else @status = :failed @error_message = charge . error_message self end else @status = :failed @error_message = \"Invalid user information. Please check the errors below.\" self end end def successful? @status == :success end end 然後原先的 create 方法就可以進行重構，如下 app/controllers/users_controller.rb: class UsersController < ApplicationController ... 程式碼省略 ... def create @user = User . new ( user_params ) # 使用者註冊 result = UserSignup . new ( @user ) . sign_up ( params [ :stripeToken ] ) if result . successful? session [ :user_id ] = @user . id flash [ :success ] = \"Thank you for registering with MyFlix.\" redirect_to home_path else flash [ :danger ] = result . error_message render :new end end end 如此一來，除了 Controller 變得簡潔， 也更容易對 create 和 UserSignup 編寫測試。","url":"http://tsaith.github.io/shi-yong-service-objects-bian-xie-zhu-ce-fu-wu.html"},{"tags":"Web","title":"使用 Decorator 作為物件的表達層","text":"這篇文章將介紹如何使用 Decorator Pattern 的技巧來封裝物件的表達邏輯。 假設有個頁面的部分程式碼如下 % header % h3 #{@video.title} % span Rating : - if @video . rating = \" #{ @video . rating } /5.0\" - else N / A % p #{@video.description} 若想將上面的程式碼簡化成 % header % h3 #{@video.title} % span Rating : = @video . rating % p #{@video.description} 一種做法是將顯示 video rating 相關的邏輯放到 Video model 裡面， 但這卻會造成物件的表達邏輯與基本方法混合在一起; 這時候比較好的做法是使用 decorator 來封裝物件的表達邏輯。 下面我們將示範如何透過 Draper gem 來編寫 decorator。 安裝套件 在 Gemfile 加入 gem 'draper' 然後執行 bundle install 。 使用範例 請在 app/decorators/ 下面新增檔案 video_decorator.rb 並加入內容如下 app/decorators/video_decorator.rb: class VideoDecorator < Draper :: Decorator delegate_all # 引入 Video model 的所有方法 def rating object . rating . present? ? \" #{ object . rating } /5.0\" : \"N/A\" end end 在 VideoController 裡面，使用 decorate 來設定 @video app/controllers/videos_controller.rb: class VideosController < ApplicationController ... 省略程式碼 ... def show @video = Video . find_by ( slug : params [ :id ] ) . decorate #@video = Video.find_by(slug: params[:id]) end end 之後就可以在 view 裡面使用 @video.rating % header % h3 #{@video.title} % span Rating : = @video . rating % p #{@video.description}","url":"http://tsaith.github.io/shi-yong-decorator-zuo-wei-wu-jian-de-biao-da-ceng.html"},{"tags":"Web","title":"在整合測試中執行 Javascript","text":"這篇文章將介紹如何使用 Capybara 來測試內含 javascript 的頁面。 安裝套件 在 Gemfile 加入 gem 'capybara' gem 'selenium-webdriver' gem 'capybara-webkit' 然後執行 bundle install 安裝套件。 設定 port 請在 spec_helper.rb 裡面設定 Capybara 所使用的 port spec/spec_helper.rb: Capybara . server_port = 52662 # this line is required by Selenium 使用說明 撰寫 整合測試 時， 只要加入 js: true ， Capybara 就會自動使用預設的 Selenium 開啓 Firefox 進行測試， 如下面的範例 spec/features/user_registers_spec.rb: require 'spec_helper.rb' feature \"User registers\" , { js : true , vcr : true } do # 請加入 js: true background do page . driver . allow_url ( \"js.stripe.com\" ) page . driver . allow_url ( \"api.stripe.com\" ) page . driver . allow_url ( \"www.gravatar.com\" ) visit sign_up_path end after { clear_email } scenario \"with valid user info and valid card\" do fill_in_valid_user_info fill_in_valid_card click_button \"Sign Up\" expect_to_see_welcome_message end scenario \"with valid user info and invalid card\" do fill_in_valid_user_info fill_in_invalid_card click_button \"Sign Up\" expect_to_see_invalid_card_message end def fill_in_valid_user_info fill_in \"Email Address\" , with : \"cloud@example.com\" fill_in \"Password\" , with : \"password\" fill_in \"Full Name\" , with : \"Cloud Strife\" end def fill_in_valid_card fill_in \"Credit Card Number\" , with : \"4242424242424242\" fill_in \"Security Code\" , with : \"123\" select \"4 - April\" , from : \"date_month\" select \"2018\" , from : \"date_year\" end def fill_in_invalid_card fill_in \"Credit Card Number\" , with : \"4242424242424242\" fill_in \"Security Code\" , with : \"\" select \"4 - April\" , from : \"date_month\" select \"2018\" , from : \"date_year\" end def expect_to_see_welcome_message expect ( page ) . to have_content \"Welcome, Cloud Strife\" end def expect_to_see_invalid_card_message expect ( page ) . to have_content \"Your card's security code is invalid.\" end end 使用 Selenium 的優點是可以看到瀏覽器執行測試的過程， 方便偵錯， 而缺點是比較花時間。 倘若希望加快測試速度， 則可以在 spec_helper.rb 裡面將預設改成 :webkit ，如下 Capybara . javascript_driver = :webkit 此外，我們可以使用 :driver 以指定某個測試希望使用的驅動引擎 describe 'some stuff which requires js' , :js => true do it 'will use the default js driver' it 'will switch to one specific driver' , :driver => :selenium end","url":"http://tsaith.github.io/zai-zheng-he-ce-shi-zhong-zhi-xing-javascript.html"},{"tags":"Web","title":"在測試中模擬物件行為","text":"當我們希望對某個開發中的功能進行測試， 而那個功能需要其他物件的支援才能工作的話， 此時可以使用 double 來 模擬 週邊物件並定義行為; 如此一來， 我們就能將精神完全投入在開發中的功能， 而不用同時兼顧其他地方。 假設我們現在想設計一個網站， 使用者在註冊時必須刷卡付費來使用內部服務。 倘若我們剛編寫了創造使用者的 create 方法，如下 users_controller.rb: class UsersController < ApplicationController ... 程式碼省略 ... def create @user = User . new ( user_params ) if @user . valid? # 信用卡交易 charge = StripeWrapper :: Charge . create ( :amount => 999 , # in cents :currency => \"usd\" , :card => params [ :stripeToken ] , :description => \"Sign up for #{ @user . email } \" ) if charge . successful? @user . save session [ :user_id ] = @user . id AppMailer . delay . send_welcome_email ( @user ) flash [ :success ] = \"You are registered.\" redirect_to home_path else flash [ :danger ] = charge . error_message render :new end else flash [ :danger ] = \"There's something wrong during registration.\" render :new end end ... 程式碼省略 ... end 這個方法裡面， 使用了信用卡服務來索取註冊費用; 而當編寫測試時， 我們會希望單純地測試 create 方法的邏輯是否正確， 這時候就可以考慮使用 double 來模擬信用卡交易的行為 users_controller_spec.rb: require \"spec_helper\" describe UsersController do describe \"POST create\" do context \"with valid personal info and valid card\" do # 當交易成功時 successful? 方法將回傳 true let ( :charge ) { double ( :charge , successful? : true ) } before do # 預期將會呼叫到 StripeWrapper::Charge.create 方法，並回傳 charge 物件 StripeWrapper :: Charge . should_receive ( :create ) . and_return ( charge ) end after { ActionMailer :: Base . deliveries . clear } it \"creates the user\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( User . count ) . to eq 1 end it \"sets flash success message\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( flash [ :success ] ) . to be_present end it \"redirects to the home page\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( response ) . to redirect_to home_path end it \"sends out email to the user\" do post :create , user : { email : \"alice@example.com\" , password : \"password\" , full_name : \"Alice Liddel\" } message = ActionMailer :: Base . deliveries . last expect ( message . to ) . to eq [ \"alice@example.com\" ] end end context \"with valid personal info and declined card\" do # 交易失敗時，successful? 方法回傳 false， error_message 回傳錯誤訊息 let ( :charge ) { double ( :charge , successful? : false , error_message : \"Your card was declined.\" ) } before do # 預期將會呼叫到 StripeWrapper::Charge.create 方法，並回傳 charge 物件 StripeWrapper :: Charge . should_receive ( :create ) . and_return ( charge ) end after { ActionMailer :: Base . deliveries . clear } it \"does not create the user\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( User . count ) . to eq 0 end it \"renders the :new template\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( response ) . to render_template :new end it \"sets @user\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( assigns ( :user )) . to be_instance_of User end it \"sets the flash danger message\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( flash [ :danger ] ) . to be_present end it \"does not send out email\" do post :create , user : Fabricate . attributes_for ( :user ), stripeToken : \"123\" expect ( ActionMailer :: Base . deliveries ) . to be_empty end end context \"with invalid personal info\" do after { ActionMailer :: Base . deliveries . clear } it \"does not create the user\" do post :create , user : Fabricate . attributes_for ( :user , password : \"\" ) expect ( User . count ) . to eq 0 end it \"renders the :new template\" do post :create , user : Fabricate . attributes_for ( :user , password : \"\" ) expect ( response ) . to render_template :new end it \"sets @user\" do post :create , user : Fabricate . attributes_for ( :user , password : \"\" ) expect ( assigns ( :user )) . to be_instance_of User end it \"sets the flash danger message\" do post :create , user : Fabricate . attributes_for ( :user , password : \"\" ) expect ( flash [ :danger ] ) . to be_present end it \"does not send out email\" do post :create , user : { email : \"alice@example.com\" } expect ( ActionMailer :: Base . deliveries ) . to be_empty end end end end 在測試中模擬物件的技巧， 一方面讓我們可以專心地測試正在開發的功能， 另一方面，也可以縮短呼叫物件時等候回應的時間， 以提升測試效率。","url":"http://tsaith.github.io/zai-ce-shi-zhong-mo-ni-wu-jian-xing-wei.html"},{"tags":"Web","title":"獨立的 API 測試","text":"撰寫測試時， 如果需要透過網路來呼叫外部服務的 API (例如信用卡的交易服務)， 因為 API 的回應通常需要一陣子， 這將大幅延長測試所需的等候時間; 此時可以考慮使用 VCR (Video Cassette Recorder) 先將服務的回應記錄下來， 往後當呼叫到此服務的 API 時就自動播放， 以縮短測試時間。 安裝套件 在 Gemfile 中加入 group : test do gem 'vcr' gem 'webmock' end 然後執行 bundle install 設定 VCR 在 spec_helper.rb 裡面設定 VCR 如下， 若想了解更多細節可參考 Relish 的 文件 。 spec/spec_helper.rb: require 'vcr' VCR . configure do | c | c . cassette_library_dir = 'spec/cassettes' c . hook_into :webmock c . configure_rspec_metadata! c . ignore_localhost = true # 忽略本地端的 request end RSpec . configure do | config | # 在 RSpec 3 不再需要此行 config . treat_symbols_as_metadata_keys_with_true_values = true ... 程式碼省略 ... end 加入 :vcr 現在， 只要在測試中加入 :vcr 就會自動記錄 API 的回應， 請參考下面的範例 stripe_wrapper_sepc.rb: require 'spec_helper' describe StripeWrapper :: Charge do let ( :token ) do Stripe :: Token . create ( :card => { :number => card_number , :exp_month => 1 , :exp_year => 2016 , :cvc => \"314\" , :description => \"some description\" } ) . id end context \"with valid card\" do let ( :card_number ) { '4242424242424242' } it \"charges the card successfully\" , :vcr do # 加入 :vcr response = StripeWrapper :: Charge . create ( amount : 300 , card : token ) expect ( response ) . to be_successful end end context \"with invalid card\" do let ( :card_number ) { '4000000000000002' } it \"does not charge the card successfully\" , :vcr do # 加入 :vcr response = StripeWrapper :: Charge . create ( amount : 300 , card : token ) expect ( response ) . not_to be_successful end it \"contains an error message\" , :vcr do # 加入 :vcr response = StripeWrapper :: Charge . create ( amount : 300 , card : token ) expect ( response . error_message ) . to be_present end end end 請注意，加入 :vcr 後的第一次測試， 仍會呼叫到外部服務，並記錄服務的回應; 之後的測試，才會直接使用先前的記錄。 在 spec/cassettes 裡面可以找到有哪些回應被記錄下來，如下 $ tree spec/cassettes spec/cassettes └── StripeWrapper_Charge ├── with_invalid_card │ ├── contains_an_error_message.yml │ └── does_not_charge_the_card_successfully.yml └── with_valid_card └── charges_the_card_successfully.yml 3 directories, 3 files","url":"http://tsaith.github.io/du-li-de-api-ce-shi.html"},{"tags":"Web","title":"在測試中使用 Database Cleaner","text":"通常，我們在執行自動測試時， 會希望資料庫裡面沒有之前剩餘的記錄， 不然很容易導致難以發現的錯誤。 這裡將介紹如何使用 Database Cleaner ， 讓每次測試前可以自動完成資料庫的清理。 安裝套件 在 Gemfile 裡面加入 gem 'database_cleaner' 然後執行 bundle install 。 進行設定 若是用 RSpec 編寫測試， 請先將 spec_helper.rb 裡面的這一行 config . use_transactional_fixtures = true 修改成 config . use_transactional_fixtures = false 然後在 spec/support/ 裡面新增 database_cleaner.rb ， 內容如下 spec/support/database_cleaner.rb: RSpec . configure do | config | config . before ( :suite ) do DatabaseCleaner . clean_with ( :truncation ) end config . before ( :each ) do DatabaseCleaner . strategy = :transaction end config . before ( :each , :js => true ) do DatabaseCleaner . strategy = :truncation end config . before ( :each ) do DatabaseCleaner . start end config . after ( :each ) do DatabaseCleaner . clean end end { % endcodeblock % } 若不清楚上述設定的意義， 可以參考 Avdi Grimm 的 原文 ，其中有詳細的說明。","url":"http://tsaith.github.io/zai-ce-shi-zhong-shi-yong-database-cleaner.html"},{"tags":"Web","title":"信用卡交易服務: Stripe","text":"這篇文章將介紹如何在 Rails 中使用 Stripe 來處理信用卡交易; Stripe 相較於 Paypal 的優點除了設定簡單、安全性高、費用較低，同時還為您處理了繁雜的 merchant account 交易問題。 基於上述理由，Stripe 在國外已經成為相當受到矚目的金流明星， 並且支援大陸的 支付寶 ， 然而在台灣尚未開放使用，希望這家公司能早日進軍台灣的市場。 安裝套件 在 Gemfile 中加入 gem 'stripe' , :git => 'https://github.com/stripe/stripe-ruby' gem 'figaro' 然後執行 bundle install 進行安裝。 註冊帳號 先到 Stripe 進行註冊， 註冊後，請在您帳號下取得 API Keys 。 設定 API Keys 這裡我們使用 figaro 來儲存不同環境(開發、測試或上線)下的 API keys。 請在專案目錄下，執行 figaro install ，這命令將 自動產生 config/application.yml 將此檔案加到 .gitignore 裡面 然後在 application.yml 裡面加入 keys config/application.yml: development : STRIPE_PUBLISHABLE_KEY : 您的 test publishable key STRIPE_SECRET_KEY : 您的 test secret key test : STRIPE_PUBLISHABLE_KEY : 您的 test publishable key STRIPE_SECRET_KEY : 您的 test secret key production : STRIPE_PUBLISHABLE_KEY : 您的 live publishable key STRIPE_SECRET_KEY : 您的 live secret key 處理交易 倘若我們想設計一個網站， 讓使用者可以刷卡來支付網站的註冊費用。 參考 Stripe 的 說明 ， 然後在處理註冊行為的 controller 中， 加入對應的程式碼 users_controller.rb: class UsersController < ApplicationController ... 省略程式碼 ... def create @user = User . new ( user_params ) if @user . save session [ :user_id ] = @user . id handle_invitation AppMailer . delay . send_welcome_email ( @user ) flash [ :success ] = \"Your are registered.\" # 使用 Stripe 服務 Stripe . api_key = ENV [ 'STRIPE_SECRET_KEY' ] token = params [ :stripeToken ] begin Stripe :: Charge . create ( :amount => 999 , # in cents :currency => \"usd\" , :card => token , :description => \"Sign up for #{ @user . email } \" ) rescue Stripe :: CardError => e flash [ :danger ] = e . message end redirect_to home_path else flash [ :danger ] = \"There's something wrong during registration.\" render :new end end ... 省略程式碼 ... end 內嵌表格 使用 Stripe 所提供 Checkout ， 可以簡單地地加入交易按鈕，如下所示 點選按鈕後，使用者可以在跳出的表格內輸入信用卡資訊，然後送出 對應的程式碼如下 app/views/users/new.html.haml %section .register.container .row .col-sm-10.col-sm-offset-1 = bootstrap_form_for @user , layout : :horizontal , lablel_col : \"col-sm-2\" , control_col : \"col-sm-6\" do | f | %header %h1 Register %fieldset = f . email_field :email , label : \"Email Address\" = f . password_field :password = f . text_field :full_name , label : \"Full Name\" = hidden_field_tag :invitation_token , @invitation_token = f . form_group do -# Stripe 提供的 javascript <script src=\"https://checkout.stripe.com/checkout.js\" class=\"stripe-button\" data-key= #{ ENV [ 'STRIPE_PUBLISHABLE_KEY' ] } data-amount=\"999\" data-name=\"MyFlix Sign Up Charge\" data-description=\"$9.99 for the best video service\"> </script> 自定表格 假設我們希望自定信用卡的交易表格， 那可以參考 Stripe Custom Forms 的流程， 直接在 view 中使用 Stripe.js ， 如以下範例 app/views/users/new.html.haml: <script type=\"text/javascript\" src=\"https://js.stripe.com/v2/\"></script> <script type=\"text/javascript\"> Stripe.setPublishableKey(\" #{ ENV [ 'STRIPE_PUBLISHABLE_KEY' ] } \"); </script> = javascript_include_tag 'payment' %section .register.container .row .col-sm-10.col-sm-offset-1 = bootstrap_form_for @user , layout : :horizontal , lablel_col : \"col-sm-2\" , control_col : \"col-sm-6\" , html : { id : \"payment-form\" } do | f | %header %h1 Register %fieldset = f . email_field :email , label : \"Email Address\" = f . password_field :password = f . text_field :full_name , label : \"Full Name\" = hidden_field_tag :invitation_token , @invitation_token %fieldset .credit_card %span .payment-errors .form-group %label .control-label.col-sm-2 Credit Card Number .col-sm-6 %input .form-control ( type= \"text\" data-stripe= \"number\" ) .form-group %label .control-label.col-sm-2 Security Code .col-sm-6 %input .form-control ( type= \"text\" data-stripe= \"cvc\" ) .form-group %label .control-label.col-sm-2 Expiration .col-sm-3 = select_month ( Date . today , { add_month_numbers : true }, class : 'form-control' , data : { stripe : \"exp-month\" }) .col-sm-2 = select_year ( Date . today . year , { start_year : Date . today . year , end_year : Date . today . year + 4 }, class : 'form-control' , data : { stripe : \"exp-year\" }) = f . form_group do = f . submit \"Sign up\" {% endcodeblock %} 上面程式碼所用到的 payment.js 內容如下 app/assets/javascripts/payment.js: jQuery ( function ( $ ) { $ ( '#payment-form' ). submit ( function ( event ) { var $form = $ ( this ); // Disable the submit button to prevent repeated clicks $form . find ( 'button' ). prop ( 'disabled' , true ); Stripe . card . createToken ( $form , stripeResponseHandler ); // Prevent the form from submitting with the default action return false ; }); function stripeResponseHandler ( status , response ) { var $form = $ ( '#payment-form' ); if ( response . error ) { // Show the errors on the form $form . find ( '.payment-errors' ). text ( response . error . message ); $form . find ( 'button' ). prop ( 'disabled' , false ); } else { // response contains id and card, which contains additional card details var token = response . id ; // Insert the token into the form so it gets submitted to the server $form . append ( $ ( '<input type=\"hidden\" name=\"stripeToken\" />' ). val ( token )); // and submit $form . get ( 0 ). submit (); } }; });","url":"http://tsaith.github.io/xin-yong-qia-jiao-yi-fu-wu-stripe.html"},{"tags":"Web","title":"使用 Figaro 設定環境變數","text":"開發專案時， 我們常常需要在不同的環境下(例如 development、test 或 production)為環境變數設定不同的值， 倘若每次都要手動設定， 不僅浪費時間而且很容易發生錯誤; 對於這個問題， Figaro 提供了一個簡潔的方法來處理。 安裝套件 在 Gemfile 中加入 gem 'figaro' 然後執行 bundle install 進行安裝。 設定環境變數 請在專案目錄下，執行 figaro install ，這命令將 自動產生 config/application.yml 將此檔案加到 .gitignore 裡面 然後就可以在 application.yml 裡面針對不同環境來設定變數， 如下 config/application.yml: development : SMTP_USER_NAME : test@example.com SMTP_PASSWORD : test_password test : SMTP_USER_NAME : test@example.com SMTP_PASSWORD : test_password staging : SMTP_USER_NAME : test@example.com SMTP_PASSWORD : test_password production : SMTP_USER_NAME : live@example.com SMTP_PASSWORD : live_password 設定後，請記得重新啟動伺服器以載入變數。 設定 Heroku 環境變數 Figaro 還提供了方便的指令可以一次將設定檔的環境變數輸出到 Heroku 上，如下 figaro heroku:set -e production","url":"http://tsaith.github.io/shi-yong-figaro-she-ding-huan-jing-bian-shu.html"},{"tags":"Web","title":"管理者登入機制","text":"後台管理系統是網站的一項重要功能， 使用者必須擁有管理者權限才可以在後台進行一些特定操作 (例如，新增商品、下架、查看交易記錄 ... 等); 這篇文章將敘述如何在使用者 驗證機制 中加入管理者權限，並在登入後可以訪問後台的工作頁面。 新增欄位 在 users table 加入 admin 欄位 $ rails g migration add_admin_to_users admin:boolean $ rake db:migrate 查看 admin 欄位是否已成功加入 db/schema.rb: create_table \"users\" , force : true do | t | t . string \"full_name\" t . string \"email\" t . string \"password_digest\" t . string \"slug\" t . datetime \"created_at\" t . datetime \"updated_at\" t . string \"token\" t . boolean \"admin\" # 新增的欄位 end 設定 routes 加入管理者新增影片的路徑 config/routes.rb: ... 省略程式碼 ... namespace :admin do resources :videos , only : [ :new , :create ] end Controllers 在 app/controllers/admin 目錄下， 新增 VideosController app/controllers/admin/videos_controller.rb: class Admin :: VideosController < AdminsController def new @video = Video . new end def create # ... 省略程式碼 ... end end app/controllers/admin_controller.rb: class AdminsController < AuthenticatedController before_action :require_admin end app/controllers/authenticated_controller.rb: class AuthenticatedController < ApplicationController before_action :require_user end Views 在網頁中加入連結，導向新增影片的頁面 app/views/shared/_header.html.haml: %li -# 新增影片 = link_to \"Add Video\" , new_admin_video_path if current_user . admin? = link_to \"Invite a friend\" , new_invitation_path %a ( href= \"#\" ) Account %a ( href= \"#\" ) Plan and Billing %a ( href= \"/sign_out\" ) Sign Out 在 app/views/admin/videos/ 下面加入新增影片的頁面 app/views/admin/videos/new.html.haml: %section .admin_add_video .container .row .col-md-10.col-md-offset-1 = bootstrap_form_for [ :admin , @video ] , layout : :horizontal , label_col : \"col-sm-3\" , control_col : \"col-sm-6\" do | f | %ul .nav.nav-tabs %li %a ( href= \"\" ) Recent Payments %li .active %a ( href= \"\" ) Add a New Video %br %fieldset = f . text_field :title , control_col : \"col-sm-3\" = f . select :category_id , options_from_collection_for_select ( Category . all , :id , :name ) = f . text_area :description , rows : 8 .form-group %label .control-label.col-sm-3 Large Cover .col-sm-6 %col .btn.btn-file %input .form-control ( type= \"file\" ) .form-group %label .control-label.col-sm-3 Small Cover .col-sm-6 %col .btn.btn-file %input .form-control ( type= \"file\" ) %fieldset .actions.form-group .col-sm-6.col-md-offset-3 = f . submit \"Add Video\" , class : \"btn btn-default\"","url":"http://tsaith.github.io/guan-li-zhe-deng-ru-ji-zhi.html"},{"tags":"Web","title":"使用 CarrierWave 上傳檔案到 AWS S3","text":"在網路應用中，將檔案上傳到雲端儲存服務是個常見並且重要的功能， 這篇文章將示範如何在 Rails 專案中使用 CarrierWave 將檔案上傳到 AWS S3 的實作流程。 申請 AWS S3 先在 AWS 的官網進行 註冊 ， 若是第一次使用 AWS，在登入帳號後， 需要先到 IAM 新增使用者群組並選擇適當的權限(例如 Amazon S3 Full Access)， 然後再新增一位使用者， 將使用者加入到剛剛新增的群組中， 確保該使用者有存取 S3 的權限。 最後，再到 S3 的服務下， 為專案新增 buckets 。 安裝套件 因為 CarrierWave 需要使用到 ImageMagic ， 若您的開發環境是 Mac，可以使用 Homebrew 進行安裝 brew install imagemagick 接著在 Gemfile 中加入 gem 'carrierwave' gem 'mini_magick' gem 'fog' 然後執行 bundle install 。 請注意，因為 MiniMagick 是 ImageMagick 的 Ruby 界面， 所以它的安裝順序需要在 ImageMagick 之後。 開發目標 假設我們現在希望為網站開發一個上傳影片的功能， 每部影片有兩種尺寸的封面圖片，以及影片的連結; 下面將敘述實作的流程。 新增欄位 先在資料庫的 videos table 裡面新增 large_cover 、 small_cover 以及 video_url 三個欄位，如下 db/schema.rb: create_table \"videos\" , force : true do | t | t . string \"title\" t . integer \"category_id\" t . string \"large_cover\" # 大尺寸的封面 t . string \"small_cover\" # 小尺寸的封面 t . string \"video_url\" # 影片連結 t . text \"description\" t . string \"slug\" t . datetime \"created_at\" t . datetime \"updated_at\" end 產生 uploader 在專案目錄下執行 rails generate uploader large_cover rails generate uploader small_cover 然後編輯剛產生出來的兩個 uploader 檔案，內容如下 app/uploaders/large_cover.rb: # encoding: utf-8 class LargeCoverUploader < CarrierWave :: Uploader :: Base include CarrierWave :: MiniMagick process :resize_to_fill => [ 665 , 375 ] # 圖片大小 # Override the directory where uploaded files will be stored. # This is a sensible default for uploaders that are meant to be mounted: def store_dir \"uploads/ #{ model . class . to_s . underscore } / #{ mounted_as } / #{ model . id } \" end end app/uploaders/small_cover.rb: # encoding: utf-8 class SmallCoverUploader < CarrierWave :: Uploader :: Base include CarrierWave :: MiniMagick process :resize_to_fill => [ 166 , 236 ] # 圖片大小 # Override the directory where uploaded files will be stored. # This is a sensible default for uploaders that are meant to be mounted: def store_dir \"uploads/ #{ model . class . to_s . underscore } / #{ mounted_as } / #{ model . id } \" end end 掛載 uploader 在 Video model 掛載上面產生的 uploaders，如下 app/models/video.rb: class Video < ActiveRecord :: Base mount_uploader :large_cover , LargeCoverUploader mount_uploader :small_cover , SmallCoverUploader ... 程式碼省略 ... end ### 設定雲端檔案服務 在 `config/initializers` 目錄下新增檔案 `carrierwave.rb` 設定如下 config / initializers / carrierwave . rb : :: :ruby CarrierWave . configure do | config | if Rails . env . staging? || Rails . env . production? config . storage = :fog config . fog_credentials = { :provider => 'AWS' , :aws_access_key_id => ENV [ 'AWS_ACCESS_KEY_ID' ] , :aws_secret_access_key => ENV [ 'AWS_SECRET_ACCESS_KEY' ] , :region => ENV [ 'S3_BUCKET_REGION' ] } config . fog_directory = ENV [ 'S3_BUCKET_NAME' ] else config . storage = :file config . enable_processing = Rails . env . development? end end 若在 staging 或 production 環境下， 將會透過 fog 上傳檔案到 AWS 的 bucket; 若是開發環境， 則會將檔案放在本地端的 public 目錄下。 設定 :aws_access_key_id 和 :aws_secret_access_key 時， 請使用 IAM 的使用者驗証資訊。 View 與 Controller 最後再編寫上傳檔案的界面，如下 新增影片時將會自動上傳封面圖片到遠端。 通常，我們不會直接上傳影片(因為檔案較大)到 S3， 而會使用專業的影片服務進行上傳，再儲存網址。 若是公開的影片，可以使用 YouTube ; 不公開的影片，可以考慮 Vimeo 或 Wistia 。 以下是 view 的程式碼 app/views/admin/videos/new.html.haml: %section .admin_add_video .container .row .col-md-10.col-md-offset-1 = bootstrap_form_for [ :admin , @video ] , layout : :horizontal , label_col : \"col-sm-3\" , control_col : \"col-sm-6\" do | f | %ul .nav.nav-tabs %li %a ( href= \"\" ) Recent Payments %li .active = link_to \"Add a New Video\" , new_admin_video_path %br %fieldset = f . text_field :title , control_col : \"col-sm-3\" = f . select :category_id , options_from_collection_for_select ( Category . all , :id , :name ) = f . text_area :description , rows : 8 = f . file_field :large_cover , class : \"btn btn-default btn-file\" = f . file_field :small_cover , class : \"btn btn-default btn-file\" = f . text_field :video_url , label : \"Video URL\" %fieldset .actions.form-group .col-sm-6.col-md-offset-3 = f . submit \"Add Video\" , class : \"btn btn-default\" 對應的 controller 如下 app/controllers/admin/video_controller.rb: class Admin :: VideosController < AdminsController def new @video = Video . new end def create @video = Video . new ( video_params ) if @video . save flash [ :success ] = \"You have successfully added the video ' #{ @video . title } '.\" redirect_to new_admin_video_path else flash [ :danger ] = \"You cannot add this video. Please check the errors.\" render :new end end private def video_params params . require ( :video ) . permit ( :title , :category_id , :description , :large_cover , :small_cover , :video_url ) end end","url":"http://tsaith.github.io/shi-yong-carrierwave-shang-chuan-dang-an-dao-aws-s3.html"},{"tags":"Web","title":"監視產品錯誤: Sentry","text":"當產品在線上工作時，如果發生意外的錯誤， 為了保持好的使用者體驗， 我們必須盡可能地在第一時間發現問題並迅速解決; 這裡要介紹一項好用的服務 Sentry ， 它可以為我們監控產品的運作狀況， 當錯誤發生時自動寄信通知我們並且記錄 log 中的錯誤訊息。 申請帳號 Sentry 有提供 Trial plan 只要註冊就可以免費使用; 註冊後，請先新增 Team 然後再新增 Project ， 在 Project 的設定裡面可以取得 API Key 。 安裝套件 在 Gemfile 加入 Sentry 的 Ruby 客戶端套件， raven-ruby group :production , :staging do gem \"sentry-raven\" end 然後執行 bundle install 。 接下來，請為 production 和 staging 環境， 設定 SENTRY_DSN 環境變數，如下 # 請填入專案的 API Key export SENTRY_DSN=http://public:secret@example.com/project-id 設定完成並且部署到遠端後， 以後只要產品的運作出現錯誤， Sentry 就會自動將錯誤訊息寄送到我們的信箱。","url":"http://tsaith.github.io/jian-shi-chan-pin-cuo-wu-sentry.html"},{"tags":"Web","title":"使用 paratropper 自動化部署流程","text":"假設我們已經在 Heroku 上面架設了 staging 和 production servers， 倘若每次修改完程式都要手動地處理部署的工作， 這不僅沒有效率，而且很容易發生錯誤; 所以這裡將介紹如何使用 paratrooper ，將部署的流程自動化。 安裝套件 在 Gemfile 加入 gem 'paratrooper' 然後執行 bundle install 。 設定流程 在 lib/tasks/ 裡面新增一個檔案 deploy.rake 內容如下 require 'paratrooper' namespace :deploy do desc 'Deploy app in staging environment' task :staging do deployment = Paratrooper :: Deploy . new ( \"amazing-staging-app\" , tag : 'staging' ) deployment . deploy end desc 'Deploy app in production environment' task :production do deployment = Paratrooper :: Deploy . new ( \"amazing-production-app\" ) do | deploy | deploy . tag = 'production' deploy . match_tag = 'staging' end deployment . deploy end end 注意，上面程式中的 amazing-staging-app 和 amazing-production-app ，需要修改成你的 staging 和 production 名稱。 現在，若要 deploy 到 staging 請執行 rake deploy:staging ; 倘若想 deploy 到 production 則執行 rake deploy:production 。","url":"http://tsaith.github.io/shi-yong-paratropper-zi-dong-hua-bu-shu-liu-cheng.html"},{"tags":"web","title":"在 Heroku 上架設 staging server","text":"開發專案時， 有時候我們會遇到在本地端測試過的功能無法在上線時正常運作， 這往往是因為開發環境(通常是我們的個人電腦)， 與上線的環境並不相同; 為了解決這問題， 我們將程式更新到 production 之前， 需要先在 staging server 上測試過。 簡單地說，staging 所扮演的角色就是在模擬 production; 所以，我們應該盡可能地讓 staging 環境與 production 所在的環境一致。 這裡將介紹如何在 Heroku 平台上架設 staging server。 假設，我們在 Heroku 上有一個 production 名字叫 myflix ， 而希望的 staging 名稱為 myflix-staging ; 那麼只要執行 $ heroku fork -a myflix myflix-staging Heroku 就會 fork 出 myflix-staging ，並且自動複製 myflix 的資料庫與 add-ons，讓 staging 與 production 有相同的運作環境。 此外，我們還需要在 git 中設定 myflix-staging 的 repository，之後才能將程式也 push 到 staging 中。 $ git remote add myflix-staging git@heroku.com:myflix-staging.git","url":"http://tsaith.github.io/zai-heroku-shang-jia-she-staging-server.html"},{"tags":"Misc","title":"使用 Percol 進行模糊搜尋","text":"在開發專案時，我們常常需要在眾多資料夾下搜尋某個檔案， 可是往往卻無法記得完整的檔案名稱，或是找到檔案後， 希望能快速地將檔案路徑貼到其他應用程式上面。 針對以上的問題， 網路上有篇 文章 提出了使用 percol 結合 shell 命令的解決方案。 我稍微修改了一些流程，並記錄如下。 安裝 percol 因為 percol 是用 python 開發的工具， 所以我們需要先安裝 python 環境 brew install python 接著安裝 percol pip install percol 設定 percol 快捷鍵 在 ~/.percol.d/rc.py 裡面定義常用的快捷鍵 # X / _ / X percol . view . PROMPT = \"<bold><yellow>X / _ / X</yellow></bold> %q\" # Emacs like percol . import_keymap ({ \"C-h\" : lambda percol : percol . command . delete_backward_char (), \"C-d\" : lambda percol : percol . command . delete_forward_char (), \"C-k\" : lambda percol : percol . command . kill_end_of_line (), \"C-y\" : lambda percol : percol . command . yank (), \"C-t\" : lambda percol : percol . command . transpose_chars (), \"C-a\" : lambda percol : percol . command . beginning_of_line (), \"C-e\" : lambda percol : percol . command . end_of_line (), \"C-b\" : lambda percol : percol . command . backward_char (), \"C-f\" : lambda percol : percol . command . forward_char (), \"M-f\" : lambda percol : percol . command . forward_word (), \"M-b\" : lambda percol : percol . command . backward_word (), \"M-d\" : lambda percol : percol . command . delete_forward_word (), \"M-h\" : lambda percol : percol . command . delete_backward_word (), \"C-n\" : lambda percol : percol . command . select_next (), \"C-p\" : lambda percol : percol . command . select_previous (), \"C-v\" : lambda percol : percol . command . select_next_page (), \"M-v\" : lambda percol : percol . command . select_previous_page (), \"M-<\" : lambda percol : percol . command . select_top (), \"M->\" : lambda percol : percol . command . select_bottom (), \"C-m\" : lambda percol : percol . finish (), \"C-j\" : lambda percol : percol . finish (), \"C-g\" : lambda percol : percol . cancel (), }) 定義 shell 命令 在 ~/.bash_profile 裡面自定常用的命令，如下 # file navigation with percol [ $(uname -s | grep -c CYGWIN) -eq 1 ] && OS_NAME=\"CYGWIN\" || OS_NAME=`uname -s` function pclip() { if [ $OS_NAME == CYGWIN ]; then putclip $@; elif [ $OS_NAME == Darwin ]; then pbcopy $@; else if [ -x /usr/bin/xsel ]; then xsel -ib $@; else if [ -x /usr/bin/xclip ]; then xclip -selection c $@; else echo \"Neither xsel or xclip is installed!\" fi fi fi } function ff() { local fullpath=$* local filename= ${ fullpath ##*/ } # remove \"/\" from the beginning filename= ${ filename ##*./ } # remove \".../\" from the beginning echo file= $filename # only the filename without path is needed # filename should be reasonable local cli=`find $PWD -not -iwholename '*/target/*' -not -iwholename '*.svn*' -not -iwholename '*.git*' -not -iwholename '*.sass-cache*' -not -iwholename '*.hg*' -type f -iwholename '*' ${ filename } '*' -print | percol` echo ${ cli } echo -n ${ cli } |pclip; } function h () { # reverse history, pick up one line, remove new line characters and put it into clipboard if [ -z \"$1\" ]; then history | sed '1!G;h;$!d' | percol | sed -n 's/&#94; *[0-9][0-9]* *\\(.*\\)$/\\1/p'| tr -d '\\n' | pclip else history | grep \"$1\" | sed '1!G;h;$!d' | percol | sed -n 's/&#94; *[0-9][0-9]* *\\(.*\\)$/\\1/p'| tr -d '\\n' | pclip fi } function glsf () { local str=`git --no-pager log --oneline --stat $* | percol` if [[ $str =~ &#94;[[:space:]]*([a-z0-9A-Z_.\\/-]*).*$ ]]; then echo -n ${ BASH_REMATCH [ 1 ] } | pclip; echo ${ BASH_REMATCH [ 1 ] } fi } function ppgrep() { if [[ $1 == \"\" ]]; then PERCOL=percol else PERCOL=\"percol --query $1\" fi ps aux | eval $PERCOL | awk '{ print $2 }' } function ppkill() { if [[ $1 =~ \"&#94;-\" ]]; then QUERY=\"\" # options only else QUERY=$1 # with a query [[ $# > 0 ]] && shift fi ppgrep $QUERY | xargs kill $* } 存檔後，若不想重開 terminal 可直接執行 source ~/.bash_profile 就可以立刻使用上面定義的命令。 使用範例 在專案下執行 ff ，可以使用片段的檔名進行搜尋， 選擇檔案後按 Return 就會自動將檔名拷貝到系統的剪貼簿上。 直接執行 h ，可搜尋並拷貝歷史命令。 如果想強制離開搜尋畫面，請按 Ctrl + c 。","url":"http://tsaith.github.io/shi-yong-percol-jin-xing-mo-hu-sou-xun.html"},{"tags":"Web","title":"使用 Procfile 和 Foreman","text":"架設在 Heroku 上面的 app， 會使用一個檔案 Procfile 來宣告有哪些命令將被 dynos 所執行。 Procfile 是位於專案下的一個文字檔， 在檔案的內容中， 左側指定 process type，而右側是要執行的命令， 如以下的範例 {% codeblock Procfile %} web: bundle exec rails server -p $PORT {% endcodeblock %} 在 Heroku 上 $PORT 的預設值是 5000 。 使用 Foreman 在本地端開發或偵錯應用程式時， 應該與遠端採用同樣的執行步驟， 以避免因為步驟的不同而造成難以發現的錯誤。 Heroku Toolbelt 提供了一個命令 foreman ， 讓我們可以在本地端按照 Procfile 的內容來啟動 app。 假設我們使用的 Profile 內容為 web : bundle exec rails server - p $PORT 執行 foreman start 後，將可以看到訊息如下 $ foreman start 09:09:59 web.1 | started with pid 3111 這時候連到 http://localhost:5000/ 就可以看到已啟動的服務。","url":"http://tsaith.github.io/shi-yong-procfile-he-foreman.html"},{"tags":"Web","title":"在 Heroku 上架設 concurrent server","text":"這篇文章將介紹如何使用 Unicorn 和 Sidekiq 在 Heroku 上架設能夠處理 concurrent requests 的伺服器。 申請 Redis To Go 因為 Sidekiq 需要用到 Redis ， 所以需要先在 Heroku 為你的 app 申請免費的 Redis To Go 服務。 安裝 gems 在專案目錄下的 Gemfile 中加入 gem 'unicorn' gem 'sidekiq' 然後執行 bundle install 。 設定 Unicorn 在 config/ 下新增檔案 unicorn.rb ，內容如下 config/unicorn.rb: worker_processes Integer ( ENV [ \"WEB_CONCURRENCY\" ] || 3 ) timeout 15 preload_app true before_fork do | server , worker | Signal . trap 'TERM' do puts 'Unicorn master intercepting TERM and sending myself QUIT instead' Process . kill 'QUIT' , Process . pid end defined? ( ActiveRecord :: Base ) and ActiveRecord :: Base . connection . disconnect! end after_fork do | server , worker | Signal . trap 'TERM' do puts 'Unicorn worker intercepting TERM and doing nothing. Wait for master to send QUIT' end defined? ( ActiveRecord :: Base ) and ActiveRecord :: Base . establish_connection end 關於 Unicorn 的設定，Heroku 有提供詳細的 說明 。 設定 Procfile 在專案目錄下設定 Procfile ，如下 web : bundle exec unicorn - p $PORT - c ./ config / unicorn . rb worker : bundle exec sidekiq - c 2 - v 最後，再將專案部署到 Heroku 就完成了; 倘若想檢查目前有幾個 dynos 正在運行， 可以執行 heroku ps 來查看狀態。 同場加映 在上面的設定中，一共會使用到兩個 dynos; 一個給 web，另一個給 Sidekiq。 但 Heroku 的免費方案只提供一個 dyno， 倘若只是想要練習， 我們可以修改 unicorn.rb ， 要求 unicorn 的 worker 來跑 Sidekiq config/unicorn.rb: worker_processes Integer ( ENV [ \"WEB_CONCURRENCY\" ] || 3 ) timeout 15 preload_app true before_fork do | server , worker | Signal . trap 'TERM' do puts 'Unicorn master intercepting TERM and sending myself QUIT instead' Process . kill 'QUIT' , Process . pid end defined? ( ActiveRecord :: Base ) and ActiveRecord :: Base . connection . disconnect! # 加入這一行 @sidekiq_pid ||= spawn ( \"bundle exec sidekiq -c 2\" ) end after_fork do | server , worker | Signal . trap 'TERM' do puts 'Unicorn worker intercepting TERM and doing nothing. Wait for master to send QUIT' end defined? ( ActiveRecord :: Base ) and ActiveRecord :: Base . establish_connection end 然後再修改 Procfile ，保留 web dyno 即可。 web : bundle exec unicorn - p $PORT - c ./ config / unicorn . rb","url":"http://tsaith.github.io/zai-heroku-shang-jia-she-concurrent-server.html"},{"tags":"Web","title":"使用 Sidekiq 處理背景工作","text":"這裡將介紹如何使用 Sidekiq 透過 threads 同時處理多項工作; 例如我們將比較花費時間的動作放到背景處理， 以提升使用者的操作體驗。 安裝 Sidekiq 在 Gemfile 中加入 gem 'sidekiq' 然後執行 bundle 。 安裝 redis Sidekiq 執行時需要使用到 redis ， 倘若開發環境是 Mac 的話， 可以使用 Homebrew 進行安裝 brew install redis 啟動 redis 和 sidekiq servers redis: 執行 redis-server sidekiq: 在 Rails 專案下，執行 bundle exec sidekiq 程式範例 假設我們有一個寄送信件的動作如下 AppMailer . send_welcome_email ( @user ) . deliver 只要使用 Sidekiq 的 delay method 就可以很容易地將動作放到背景處理 AppMailer . delay . send_welcome_email ( @user ) 在 Heroku 上設定 Redis 路徑 倘若您的網站架設在 Heroku 上， 並且使用 Redis to Go ， 由於 Sidekiq 是以 REDIS_PROVIDER 環境變數來設定 Redis 的路徑， 然而 Heroku 所提供的環境變數是 REDISTOGO ; 所以我們可以執行下面的指令來連接這兩個環境變數 heroku config:set REDIS_PROVIDER=REDISTOGO 之後， 可以執行 heroku config 確認環境變數是否已設定成功，如下 $ heroku config === chlin-conifer Config Vars RACK_ENV: production RAILS_ENV: production REDISTOGO_URL: redis://redistogo:42528ab79e9e15ef9693733239b2d2c6@ray.redistogo.com:9795/ REDIS_PROVIDER: REDISTOGO_URL","url":"http://tsaith.github.io/shi-yong-sidekiq-chu-li-bei-jing-gong-zuo.html"},{"tags":"Web","title":"Heroku 上的郵件服務: Mailgun","text":"信件服務對許多網路應用都是相當重要的一環， 雖然我們可以使用免費的 gmail 帳號來寄送郵件， 但因為 gmail 每天可寄送的郵件數量有一定的上限(目前是每天 2,000 封)以及其他 限制 ， 所以在正式上線的環境， 我們還是會使用專業的郵件服務，例如 Mailgun ; 接下來將介紹如何在 Heroku 上使用 Mailgun add-on 。 申請 Mailgun add-on 登入 Heroku 後填寫信用卡資料， 然後就可以申請免費的 Mailgun starter plan 。 設定郵件環境 在 config/environments/production.rb 裡面加入 # Mailer config . action_mailer . default_url_options = { :host => 'yourapp.herokuapp.com' } # 修改為您的 host config . action_mailer . delivery_method = :smtp config . action_mailer . smtp_settings = { address : ENV [ 'MAILGUN_SMTP_SERVER' ] , port : ENV [ 'MAILGUN_SMTP_PORT' ] , user_name : ENV [ 'MAILGUN_SMTP_LOGIN' ] , password : ENV [ 'MAILGUN_SMTP_PASSWORD' ] , domain : 'yourapp.herokuapp.com' , # 修改為您的 domain authentication : :plain , } 設定完後，將專案部署到 Heroku 上面即可開始工作。","url":"http://tsaith.github.io/heroku-shang-de-you-jian-fu-wu-mailgun.html"},{"tags":"Web","title":"使用 Concerns 幫 Model 瘦身","text":"設定模組路徑 在 config/application.rb 加入 config . autoload_paths += %W( #{ Rails . root } /lib) # module paths 來告訴 Rails 自動載入專案 lib 下的 module files 抽出可共用的邏輯 假設我們有一個 Invitation model， 裡面定義了 token 的產生和清除 app/models/invitation.rb: class Invitation < ActiveRecord :: Base before_create :generate_token # 在 create 前自動產生 token belongs_to :inviter , class_name : \"User\" validates_presence_of :recipient_name , :recipient_email , :message def generate_token # 產生 token self . token = SecureRandom . urlsafe_base64 end def clear_token # 清除 token self . update_column ( :token , nil ) end end 這時候我們可以考慮使用 ActiveSupport::Concern 將 token 處理的相關邏輯抽離出來並封裝成一個模組，如下 lib/tokenable.rb: module Tokenable extend ActiveSupport :: Concern included do before_create :generate_token end def generate_token self . token = SecureRandom . urlsafe_base64 end def clear_token self . update_column ( :token , nil ) end end 然後，原先的 model 就可以改寫成 app/models/invitation.rb: class Invitation < ActiveRecord :: Base include Tokenable # 處理 token belongs_to :inviter , class_name : \"User\" validates_presence_of :recipient_name , :recipient_email , :message end 正如所見，改寫後的 model 變得更加簡潔; 此外，倘若其他 model 需要同樣功能時，也可以很方便地調用已封裝好的模組。 對於此議題，在 DHH 的 文章 中有更詳細的討論。","url":"http://tsaith.github.io/shi-yong-concerns-bang-model-shou-shen.html"},{"tags":"Web","title":"在網站中加入 Invite 功能","text":"這裡將介紹如何實作邀請朋友來網站註冊的功能。 操作流程 使用者可在邀請頁面填寫朋友的名字、郵件地址以及邀請訊息， 然後送出 然後，被邀請者將會收到邀請信， 內附連結可導向網站的註冊頁面 被邀請者進行註冊，然後登入 網站自動為邀請人與被邀請者設定互相跟隨的關係 (若想知道如何開發跟隨功能，請參考另一篇 文章 ) 設定路徑 在 routes.rb 中加入 config/routes.rb: ... 省略程式碼 ... get 'sign_up' , to : 'users#new' get 'sign_up/:token' , to : 'users#new_with_invitation_token' , as : 'sign_up_with_invitation_token' resources :invitations , only : [ :new , :create ] get 'expired_token' , to : 'pages#expired_token' Database 在資料庫新增 invitaions table db/schema.rb: ... 省略程式碼 ... create_table \"invitations\" , force : true do | t | t . integer \"inviter_id\" t . string \"recipient_name\" t . string \"recipient_email\" t . text \"message\" t . string \"token\" t . datetime \"created_at\" t . datetime \"updated_at\" end Controllers 使用者可以藉由 invitation token 進行註冊 app/controllers/users_controller.rb: class UsersController < ApplicationController ... 省略程式碼 ... def new @user = User . new end def new_with_invitation_token # 使用 invitation token 註冊 invitation = Invitation . where ( token : params [ :token ] ) . first if invitation @invitation_token = invitation . token @user = User . new ( email : invitation . recipient_email ) render :new else redirect_to expired_token_path end end def create @user = User . new ( user_params ) if @user . save session [ :user_id ] = @user . id handle_invitation # 自動設定邀請者與被邀請者互相跟隨的關係 AppMailer . send_welcome_email ( @user ) . deliver flash [ :notice ] = \"Your are registered.\" redirect_to home_path else flash [ :error ] = \"There's something wrong during registration.\" render :new end end private ... 省略程式碼 ... def handle_invitation invitation = Invitation . where ( token : params [ :invitation_token ] ) . first if invitation @user . follow ( invitation . inviter ) invitation . inviter . follow ( @user ) invitation . clear_token end end end 處理邀請記錄 app/controllers/invitations_controller.rb: class InvitationsController < ApplicationController before_action :require_user def new @invitation = Invitation . new end def create @invitation = current_user . invitations . build ( invitation_params ) if @invitation . save # 成功新增邀請 AppMailer . send_invitation_email ( @invitation ) . deliver flash [ :success ] = \"You have successfully invited #{ @invitation . recipient_name } .\" redirect_to new_invitation_path else @invitation = Invitation . new flash [ :error ] = \"Failed to invite your friend.\" render :new end end private def invitation_params params . require ( :invitation ) . permit ( :recipient_name , :recipient_email , :message ) end end Views 先在適當的頁面加入邀請連結 app/views/shared/_header.html.haml: ... 省略程式碼 ... %li = link_to \"Invite a friend\" , new_invitation_path # 邀請連結 %a ( href= \"#\" ) Account %a ( href= \"#\" ) Plan and Billing %a ( href= \"/sign_out\" ) Sign Out 新增邀請頁面 app/views/invitations/new.html.haml: %section .invite.container .row .col-sm-10.col-sm-offset-1 = bootstrap_form_for @invitation do | f | %header %h1 Invite a friend to join MyFlix! %fieldset .row .col-sm-4 = f . text_field :recipient_name , label : \"Friend's Name\" = f . email_field :recipient_email , label : \"Friend's Email Address\" = f . text_area :message , label : \"Message\" , value : \"Please join this really cool site!\" , rows : 6 = f . submit \"Send Invitation\" 在註冊頁面加入隱藏的 invitation token app/views/users/new.html.haml: %section .register.container .row .col-sm-10.col-sm-offset-1 -#%form.form-horizontal = bootstrap_form_for @user do | f | %header %h1 Register .row .col-sm-4 = f . email_field :email , label : \"Email Address\" = f . password_field :password = f . text_field :full_name , label : \"Full Name\" -# 隱藏的 invitation token = hidden_field_tag :invitation_token , @invitation_token = f . submit \"Sign up\" 顯示連結過期的頁面 app/views/pages/expired_token.html.haml: %section .invalid_token.container .row .col-sm-10.col-sm-offset-1 %p Your link is expired. Models app/models/invitation.rb: class Invitation < ActiveRecord :: Base before_create :generate_token belongs_to :inviter , class_name : \"User\" validates_presence_of :recipient_name , :recipient_email , :message def generate_token self . token = SecureRandom . urlsafe_base64 end def clear_token self . update_column ( :token , nil ) end end app/models/user.rb: class User < ActiveRecord :: Base ... 省略程式碼 ... has_many :invitations , foreign_key : \"inviter_id\" def follow ( another_user ) following_relationships . create ( leader : another_user ) if can_follow? ( another_user ) end def follows? ( another_user ) following_relationships . map ( & :leader ) . include? ( another_user ) end def can_follow? ( another_user ) ! ( self == another_user || self . follows? ( another_user )) end end Mailer 新增寄送邀請信的方法 app/mailers/app_mailer.rb: class AppMailer < ActionMailer :: Base default from : ENV [ 'MYFLIX_SMTP_USER_NAME' ] ... 省略程式碼 ... def send_invitation_email ( invitation ) @invitation = invitation mail ( to : @invitation . recipient_email , subject : \"Invitation to join MyFlix!\" ) end end 信件內容如下 app/views/app_mailer/send_invitation_email.html.haml: !!! 5 %html ( lang= \"en-US\" ) %body %p You are invited by #{ @invitation . inviter . full_name } to join MyFlix! %p #{ @invitation . message } %p = link_to \"Accept this invitation\" , sign_up_with_invitation_token_url ( @invitation . token )","url":"http://tsaith.github.io/zai-wang-zhan-zhong-jia-ru-invite-gong-neng.html"},{"tags":"Misc","title":"在 Emacs 中使用 Vim: Evil","text":"過去十多年來， Vim 一直都是筆者最喜愛的文字編輯器， 然而就像其他許多資深的 Vim 使用者， 我也總是對另一套神器 Emacs 感到好奇; 於是前陣子， 終於下定決心花些時間去了解 Emacs 的使用方式。 而在體驗之後只能說，果然盛名之下無虛士， 難怪有人會講， Emacs 根本就是偽裝成編輯器的作業系統! 就我個人主觀的看法， Vim 因為支援許多單鍵的編輯功能， 所以在文本編輯上比較快速， 而 Emacs 因為使用 Lisp 語言， 所以在擴展性上相對強大。 那我們最後應該使用哪一套工具呢? 因為 Evil 的出現， 我們現在可以直接在 Emacs 中使用 Vim，魚與熊掌兼得！ 安裝 Evil M - x package-install Ret evil Ret 設定配置 在 ~/.emacs/init.el 裡面加入 (require 'evil) (evil-mode 1) 使用方法 C - z : 在 Emacs 和 Vim 之間切接","url":"http://tsaith.github.io/zai-emacs-zhong-shi-yong-vim-evil.html"},{"tags":"Web","title":"整合測試的郵件工具: capybara-email","text":"撰寫整合測試時，倘若需要模擬點選郵件內容的連結， 進而訪問某個網頁時， 可以使用 capybara-email 這個 gem。 安裝套件 在 Gemfile 裡面加入 gem 'capybara-email' 然後執行 bundle 進行安裝。 設定郵件主機 在 config/environmnets/test.rb 加入本地端的 host，如下 config . action_mailer . default_url_options = { :host => 'localhost:3000' } 設定套件路徑 在 spec/spec_helper.rb 裡面加入 require 'capybara/email/rspec' 撰寫測試 下面的範例是用來測試使用者重設密碼的流程， 當使用者點選了郵件的連結後，將會被導向重設密碼的網頁 spec/features/user_resets_password_spec.rb: require 'spec_helper.rb' feature \"User resets password\" do scenario \"user sucessfully resets the password\" do # 在資料庫先產生一個使用者 alice alice = Fabricate ( :user , password : \"old_password\" ) # 訪問登入頁面，並點選 Forgot Password? 連結 # (然後會被導向填寫郵件地址的頁面) visit sign_in_path click_link \"Forgot Password?\" # 填寫郵件地址並送出 # (這時候網站將自動寄信給使用者，內含變更密碼的網頁連結) fill_in \"Email Address\" , with : alice . email click_button \"Send Email\" # 開啓寄給使用者的郵件，並點選信件內容中的連結 # (然後使用者會被導向設定新密碼的網頁) open_email ( alice . email ) current_email . click_link \"Reset My Password\" # 填寫新密碼，並送出 # (然後會自動回到登入頁面) fill_in \"New Password\" , with : \"new_password\" click_button \"Reset Password\" # 在登入頁面中，填寫使用者郵件地址和新密碼，然後送出 fill_in \"Email Address\" , with : alice . email fill_in \"Password\" , with : \"new_password\" click_button \"Sign in\" # 預期在更新後的網頁看到歡迎使用者的訊息 expect ( page ) . to have_content \"Welcome, #{ alice . full_name } \" end end { % endcodeblock %} {% blockquote Bill Gates %} Measuring programming progress by lines of code is like measuring aircraft building progress by weight .","url":"http://tsaith.github.io/zheng-he-ce-shi-de-you-jian-gong-ju-capybara-email.html"},{"tags":"Misc","title":"編輯器: Emacs","text":"GNU 計劃創始人 Richard Stallman 和 Guy Lewis Steele Jr. 在1975 年共同打造了 Emacs (Editor MACroS)， Emacs 使用 Lisp 作為功能擴充語言， 具有強大的擴展性，與可客製性， 還有各式各樣好用的套件， 所以也有人稱它是神的編輯器，或是偽裝成編輯器的作業系統 @_@; 如果想知道更多對於 Emcas 特性的敘述， 可以參考另一篇 文章 。 安裝 Emacs 在 Mac 下可透過 Homebrew 進行安裝 brew install emacs 建議配置 Emacs 的目錄位於 ~/.emacs.d， 若希望自定個人的專屬配置，可在 ~/.emacs.d/init.el 裡面設定。 建議一開始可直接使用高手們的配置， 因為他們的配置都經過了多年的磨練， 在深思熟慮後才決定出最佳的按鍵定義並也解決了許多套件相容性問題; 我個人偏好 Steve Purcell 的 配置 ， 因為他是一位頂尖的 Rails 開發者， 所以使用他的配置可以大量減少自己打造 Rails 開發環境的時間。 符號與按鍵 為方便之後的說明，在這邊先定義一些符號和按鍵的對應關係 C : 代表 Ctrl M : 代表 Alt Ret : 代表 Return 安裝 Packages 在 Emacs 最簡單安裝套件的兩個方式分別為 使用 package-install 命令 M - x package-install Ret Package Name Ret : 安裝套件 透過 Package Menu M - x list-packages : 進入套件安裝目錄 C - s : 尋找套件名稱 i : 標記為即將安裝的套件 u : 解除標記 d : 標記為刪除的套件 x : 開始安裝/反安裝 以標記的套件 r : 刷新列表 基本操作 C - x C - c : 離開 Emacs C - z : 暫停 Emcas，並將它放到背景 C - h C - h : Help for Help 存取檔案 C - x C - f : 尋找檔案並開啟 C - x C - s : 存檔 字元操作 C - d : 向前刪除字元 Del : 向後刪除字元 拷貝和貼上 M - w : 拷貝游標所在行 C - u 3 M - w : 拷貝連續三行 C - w : 剪下游標所在行 C - u 3 C - w : 剪下連續三行 C - y : 貼上暫存區資料 暫存區操作 C - x r s (#): 拷貝標記區域到數字暫存區 C - x r i (#): 從數字暫存區將資料插入游標所在處 Buffer 操作 C - x b : 切換 buffer C - x Left : 切換到上一個 buffer C - x Right : 切換到下一個 buffer 區段操作 C - Space : 開始標記區域 C - k : 從游標所在刪除到本行結尾 M - 0 C - k : 從游標所在刪除到本行開頭 C - x h : 標記整個檔案內容 視窗操作 C - x 1: 單一視窗 C - x 2: 水平分割 C - x 3: 垂直分割 C - x 0: 關閉選擇的視窗 M - x windmove-up: 向上切換視窗 M - x windmove-down: 向下切換視窗 M - x windmove-left: 向左切換視窗 M - x windmove-right: 向右切換視窗 移動游標 C - a : 移到游標所在行的開頭 C - e : 移到游標所在行的結尾 M - a : 移到段落開頭 M - e : 移到段落結尾 M - g g : 移到指定行數 Esc < : 移到檔案開頭 Esc > : 移到檔案結尾 C - v : 移到下一頁 M - v : 移到上一頁 C - x r Space a : 記錄目前游標位置到 register a C - x r j a : 跳到 register a 所儲存的位置 字串取代 M - % old_string Ret new_string Ret : 取代字串 M - x replace-regexp Ret regexp Ret newstring Ret : 以正規表示法取代字串 程式碼操作 M - ; : 將程式碼加上註解符號 C - u M - ; : 移除程式碼前的註解符號 Tab : 縮行對齊 M - x linum-mode: 開啟/關閉 行號顯示 其他操作 C - _ : 回到上一步 M - _ : 回到下一步 C - g : 取消目前操作 C - x z : 重複上一次的操作 M - ! : 執行外部命令 好用的 Packages Dired : 檔案管理 C - x d 開啟目錄 c 拷貝檔案 r 將檔案重新命名 d 刪除檔案 + 新增目錄 z 使用 gzip 進行壓縮/解壓縮 m 標記檔案 u 反標記檔案 U 取消所有標記 g 刷新列表 &#94; 到上一層目錄 osx-cliboard : 使用 OSX 的剪貼板 M - x osx-clipboard-mode: 進入 osx-clipboard-mode Eshell : Emacs Shell M - x eshell: 啟動 eshell Rinari : Rails 的開發環境 C - c ; f m 尋找 model C - c ; f v 尋找 view C - c ; f c 尋找 controller C - c ; f r 尋找 rspec C - c ; f M 尋找 mailer C - c ; f i 尋找 migration C - c ; f l 尋找 lib C - c ; f j 尋找 javascript C - c ; f o 尋找 log C - c ; c 啟動 console C - c ; w 啟動 web-server","url":"http://tsaith.github.io/bian-ji-qi-emacs.html"},{"tags":"Misc","title":"編輯器: Vim","text":"在編程領域中， 編輯器之戰 的兩位主角 Vi 和 Emacs 經歷幾十年的歲月後， 直到現在依然擁有許多信徒; 而隨著時間的過去， Vi (Visual， Bill Joy 於 1976 年發表 ) 的功能不斷地被增強， 最後演化出目前受歡迎的 Vim ; Vim 不管是可擴展性或高效的編輯速度， 都讓一般的編輯器難以望其項背， 也因此有了 編輯器之神 的封號! 不過 GNU 計劃的創始人 RMS 說它比較像魔鬼的編輯器 (因為 vi-vi-vi 是 獸名數目 XD ) 關於 Vim 的詳細使用方法請查詢 官方文件 ， 這裡只介紹我自己常用的一些操作。 環境設定 ~/.vimrc 環境設定檔 ~/.vim Vim 專屬的資料夾 符號定義 為方便之後的說明，先在此定義兩個按鍵符號 C 表示 Ctrl M 表示 Alt 常用模式 command mode 按 Esc insert mode 在 command mode 中，按 i 或 a plain visual mode 在 command mode 中，按 v block visual mode 在 command mode 中，按 C + v command line 在 command mode 中，按 : 存取檔案 vi file_name 開啟檔案 :w 存檔 :q 離開 :q! 強制離開(不須先存檔) :e file_name 編輯其它檔案 字元操作 i 在游標所在處開始輸入 a 從下個字元開始輸入 x 刪除一個字元 o 插入空白行並開始輸入 字元操作 d w 刪除一個單字 d W 刪除一個單字(忽略特殊字元) 拷貝和貼上 yy 拷貝游標所在的那一行 3 yy 拷貝連續三行 dd 剪下游標所在的那一行 3 dd 剪下連續三行 y 將標記區域 yank 到剪貼簿 p 將剪貼簿的資料貼上 段落操作 J 連接下一行 d $ 從游標所在刪除到本行結尾 d &#94; 從游標所在刪除到本行開頭 D 從游標所在刪除到本行結尾 暫存區操作 ma \"c y 'a 將選擇區段拷貝到 register c \"c p 將 register c 的資料貼上 ma \"+ y 'a 選擇區塊並拷貝到系統的剪貼板 3 \"+ yy 將連續三行 yank 到系統的剪貼板 :%y+ 將檔案內容 yank 到剪貼板 移動游標 gg 第一行開頭 G 最後一行的開頭 &#94; 移到游標所在行的開頭 $ 移到游標所在行的結尾 C + f 下一頁 C + b 上一頁 M + f 往後移到一個單字 M + b 往前移到一個單字 M + F 往後移到一個單字並且標記 M + b 往前移到一個單字並且標記 切換目錄 :cd %:h 將工作目錄改變到編輯的檔案下 :lcd %:h 僅將目前視窗的工作目錄改變到編輯的檔案下 autocmd BufEnter * silent! lcd %:p:h 自動改變工作目錄到編輯的檔案下 切換檔案 gf 跳到關聯檔 ( goto file ) C + &#94; 回到上一個檔案 分頁操作 :tab_new 新分頁 :tabprevious 上一個分頁 :tabnext 下一個分頁 :ab tn tab_new 將 tab_new 縮寫為 tn 視窗操作 :vs 垂直分割 :sp 水平分割 C + w v 垂直分割 C + w s 水平分割 C + w left[right] arrow 左[右]切換視窗 C + w up[down] arrow 上[下]切換視窗 C + w h[l] 左[右]切換視窗 C + w k[j] 上[下]切換視窗 其他操作 u : 回到上一步 C + r : 回到下一步 :set nu 顯示行數 :set nonu 不顯示行數 :syntax enable 語法顏色 :set ai 自動縮行 :!外部命令 執行外部命令，例如 :!ls C + r % 在 insert mode 下貼上檔案路徑 自定按鍵 map <C-k> :tabprevious <CR> 用 C + k 映射 :tabpreview map <C-j> :tabnext <CR> 用 C + j 映射 :tabnext 好用的 plugins rails.vim : Rails 套件(語法顏色，快速切換檔案... 等) :Rcd 目錄 切換目錄(從專案目錄出發) :Rmodel 檔案 編輯 model 檔案 :Rview 檔案 編輯 view 檔案 :Rcontroller 檔案 編輯 controller 檔案 snipMate : 加入程式片段 Tab 加入程式片段 ctrp : 模糊搜尋 C + p 啟動模糊搜尋 fencview.vim : 自動偵測多國編碼 :FencAutoDetect 啟動偵測 nerdtree.vim : 檔案瀏覽器 :e . 瀏覽工作目錄 supertab.vmb : 補全程式碼 Tab 補全程式碼 雖然 Vim 對初學者而言需要投入多一些的時間來熟悉， 但只要上手後， 就會大幅提升你的編程效率。","url":"http://tsaith.github.io/bian-ji-qi-vim.html"},{"tags":"Web","title":"從 rvm 遷移到 rbenv","text":"之前一直使用 rvm 來管理 ruby 的版本切換， 但因為 rvm 還提供了 gem 的安裝， 而這部分與 bundler 的職務重疊， 於是我決定採用功能更單純的 rbev 專職 ruby 版本的管理。 移除 rvm 先執行 $ rvm implode Are you SURE you wish for rvm to implode? This will recursively remove /Users/tsaith/.rvm and other rvm traces? ( anything other than 'yes' will cancel ) > yes 然後再移除使用者目錄下的 .bashrc、.bash_profile、.profile 以及 .zshrc 裡面的這一行 PATH= $ PATH : $ HOME /.rvm/bin # Add RVM to PATH for scripting 安裝 rbenv 執行 exec $SHELL -l 以重新啟動 shell 環境 加入 rbenv init - 到 shell 以使用 shims 和自動完成命令的功能 echo 'eval \"$(rbenv init -)\"' >> ~/.bash_profile source ~/.bash_profile 接著使用 Homebrew 安裝套件 brew update brew install rbenv brew install rbenv-gem-rehash brew install ruby-build 安裝 ruby 先查詢有哪些版本的 ruby 可供安裝 rbenv install -l 接著安裝指定的套件，下面以 ruby 2.1.5 的版本為例 rbenv install 2.1.5 假設在安裝 ruby 時遇到下面的錯誤訊息 BUILD FAILED (OS X 10.9.5 using ruby-build 20141225) Inspect or clean up the working tree at /var/folders/2v/wtshnx5x4294fvlxyrk9t8kh0000gn/T/ruby-build.20150111114536.6196 Results logged to /var/folders/2v/wtshnx5x4294fvlxyrk9t8kh0000gn/T/ruby-build.20150111114536.6196.log Last 10 log lines: checking whether we are using the GNU C compiler... yes checking whether gcc accepts -g... yes checking for gcc option to accept ISO C89... none needed checking whether we are using the GNU C++ compiler... yes checking whether g++ accepts -g... yes checking how to run the C preprocessor... g++ configure: error: in `/var/folders/2v/wtshnx5x4294fvlxyrk9t8kh0000gn/T/ruby-build.20150111114536.6196/ruby-2.2.0': configure: error: C preprocessor \"g++\" fails sanity check See `config.log' for more details make: *** No targets specified and no makefile found. Stop. 執行 xcode-select --install 更新 Xcode; 若在 Maverick 10.9.x 上遇到 Can't install the software because it is not currently available from the Software Update server. 這樣的錯誤訊息，可以直接到 Apple Developer 下載。","url":"http://tsaith.github.io/cong-rvm-qian-yi-dao-rbenv.html"},{"tags":"Web","title":"使用 letter_opener 檢視郵件","text":"在建構 Rails 應用時， 開發者常常需要反覆修改以及檢查欲寄送的 Email 內容是否正確， letter_opener 可以讓這工作變得更有效率。 安裝套件 在 Gemfile 裡面加入 group :development do gem 'letter_opener' end 接著執行 bundle 。 郵件設定 在 config/environments/development.rb 裡面加入 config . action_mailer . delivery_method = :letter_opener 在開發模式下，當信件被寄出時，其內容會直接顯示在瀏覽器裡面。 操作範例 開啓 rails console，寄送一封測試郵件。 $ rails c Loading development environment ( Rails 4.1.1 ) 2.1.5 :001 > AppMailer.send_welcome_email ( User.last ) .deliver 這時候 letter_opener 就會自動將信件內容傳送到瀏覽器的新分頁，如下","url":"http://tsaith.github.io/shi-yong-letter_opener-jian-shi-you-jian.html"},{"tags":"Web","title":"使用 RSpec 在 Functional Tests 裡面測試郵件","text":"這篇文章將舉一些簡單的範例來說明如何使用 RSpec 對郵件的寄送進行測試。 假設有一個 UsersController， 它的 create action 會寄送歡迎信給註冊的新使用者 app/controllers/users_controller.rb: class UsersController < ApplicationController ... 其他程式碼 ... def create @user = User . new ( user_params ) if @user . save session [ :user_id ] = @user . id flash [ :notice ] = \"Your are registered.\" # 寄送歡迎信 AppMailer . send_welcome_email ( @user ) . deliver redirect_to home_path else flash [ :error ] = \"There's something wrong during registration.\" render :new end end end 如果想要測試 create action 裡面的信件寄送， 可以撰寫 functional tests 如下 spec/controllers/users_controller_spec.rb: require \"spec_helper\" describe UsersController do describe \"POST create\" do context \"sending emails\" do # 在每個測試結束後，清除所有郵件 after { ActionMailer :: Base . deliveries . clear } # 若 inputs 有效，則寄出信件 it \"sends out email to the user with valid inputs\" do post :create , user : { email : \"alice@example.com\" , password : \"password\" , full_name : \"Alice Liddel\" } expect ( ActionMailer :: Base . deliveries ) . not_to be_empty end # 檢查收件人是否正確 it \"sends out email to the right recipient\" do post :create , user : { email : \"alice@example.com\" , password : \"password\" , full_name : \"Alice Liddel\" } message = ActionMailer :: Base . deliveries . last expect ( message . to ) . to eq [ \"alice@example.com\" ] end # 檢查信件內容是否包含使用者的名字 it \"sends out email containing the user's name with valid inputs\" do post :create , user : { email : \"alice@example.com\" , password : \"password\" , full_name : \"Alice Liddel\" } message = ActionMailer :: Base . deliveries . last expect ( message . body ) . to include \"Alice Liddel\" end # 若 inputs 無效，則不寄出信件 it \"does not send out email with invalid inputs\" do post :create , user : { email : \"alice@example.com\" } expect ( ActionMailer :: Base . deliveries ) . to be_empty end end end end 倘若不熟悉如何撰寫 functional tests 的話， 可以參考 這裡 。","url":"http://tsaith.github.io/shi-yong-rspec-zai-functional-tests-li-mian-ce-shi-you-jian.html"},{"tags":"Web","title":"實作 Follow 社交功能","text":"有使用過 Facebook 或 Twitter 的使用者們一定都不會對 Follow 這項功能感到陌生， 這裡將介紹如何實作這個機制。 Routes 在 routes.rb 中加入下列路徑 app/config/routes.rb: Myflix :: Applation . routes . draw do ... 其他程式碼 ... resources :relationships , only : [ :create , :destroy ] get 'people' , to : 'relationships#index' end Models 新增 Relationship 模型 app/models/relationship.rb: class Relationship < ActiveRecord :: Base belongs_to :leader , class_name : 'User' belongs_to :follower , class_name : 'User' end User 透過 following_relationships 和 leading_relationships 來記錄跟隨的關係;並定義 follow? 和 can_follow? 方法。 app/models/user.rb: class User < ActiveRecord :: Base ... 其他程式碼 ... has_many :relationships has_many :following_relationships , class_name : 'Relationship' , foreign_key : 'follower_id' has_many :leading_relationships , class_name : 'Relationship' , foreign_key : 'leader_id' has_many :leaders , class_name : 'User' , through : :relationships def follows? ( another_user ) following_relationships . map ( & :leader ) . include? ( another_user ) end def can_follow? ( another_user ) ! ( self == another_user || self . follows? ( another_user )) end end Controllers 新增 RelationshipsController app/controllers/relationships_controller.rb: class RelationshipsController < ApplicationController before_action :require_user def index # 顯示所有 following 關係 @relationships = current_user . following_relationships end def create # 建立 following 關係 leader = User . find ( params [ :leader_id ] ) Relationship . create ( leader : leader , follower : current_user ) if current_user . can_follow? ( leader ) redirect_to people_path end def destroy # 移除 following 關係 relationship = Relationship . find ( params [ :id ] ) relationship . destroy if relationship . follower == current_user redirect_to people_path end end Views 按下 Follow 連結可跟隨使用者 app/views/users/show.rb: %section .user.container .row .col-sm-10.col-sm-offset-1 %article %header %img ( src= \"http://www.gravatar.com/avatar/#{Digest::MD5.hexdigest(@user.email.downcase)}?s=40\" ) %h2 #{ @user . full_name } 's video collections ( #{ @user . queue_items . count } ) -# 顯示 Follow 連結 - if current_user . can_follow? ( @user ) = link_to \"Follow\" , relationships_path ( leader_id : @user . id ), method : :post , class : 'btn btn-default' %table .table %thead %tr %th ( width= \"30%\" ) Video Title %th ( width= \"15%\" ) Genre %tbody - @user . queue_items . each do | queue_item | %tr %td = link_to queue_item . video_title , queue_item . video %td = link_to queue_item . category_name , queue_item . category 顯示所有 Following 關係 app/views/relationships/index.rb: %section .people %header %h2 People I Follow %table .table %thead %tr %th ( width= \"30%\" ) %th ( width= \"20%\" ) Videos in Queue %th ( width= \"20%\" ) Followers %th ( width= \"30%\" ) Unfollow %tbody - @relationships . each do | relationship | # following 關係 %tr %td %img ( src= \"http://www.gravatar.com/avatar/#{Digest::MD5.hexdigest(relationship.leader.email.downcase)}?s=40\" ) = link_to relationship . leader . full_name , relationship . leader %td .extra-padding #{ relationship . leader . queue_items . count } %td .extra-padding #{ relationship . leader . leading_relationships . count } %td .extra-padding = link_to relationship , method : :delete do # 移除 following 關係 %i .glyphicon.glyphicon-remove","url":"http://tsaith.github.io/shi-zuo-follow-she-jiao-gong-neng.html"},{"tags":"Web","title":"透過郵件允許使用者重設密碼","text":"在許多網站的使用者登入頁面中， 通常會伴隨一個處理忘記密碼的連結， 點選後，將會寄出一封電子郵件讓使用者可以藉此重設個人密碼; 而這篇文章將介紹如何實做這項功能。 操作流程 讓我們先預覽一次整個操作流程，當訪問登入頁面時， 可以看到最下方有個 Forgot Password? 的連結 點選此連結後，會被導向新頁面， 在此可以寄送郵件到使用者的信箱 按下寄信後，將顯示信件已寄出的提示 接下來，使用者將會收到一封郵件，內含網頁連結， 點選後，將會被引導至變更密碼的頁面 最後，使用者可以在這個頁面中重新設定新的密碼 Routes 新增以下 routes config/routes.rb: get 'forgot_password' , to : 'forgot_passwords#new' resources :forgot_passwords , only : [ :create ] get 'forgot_password_confirmation' , to : 'forgot_passwords#confirm' resources :password_resets , only : [ :show , :create ] get 'expired_token' , to : 'password_resets#expired_token' Database 在 users table 裡面加入 token 欄位 db/schema.rb: create_table \"users\" , force : true do | t | t . string \"full_name\" t . string \"email\" t . string \"password_digest\" t . string \"role\" t . string \"slug\" t . datetime \"created_at\" t . datetime \"updated_at\" t . string \"token\" end Views 在登入頁面新增 Forgot Password? 連結 app/views/sessions/new.html.haml: %section .sign_in.container .row .col-sm-10.col-sm-offset-1 = bootstrap_form_tag url : sign_in_path do | f | %header %h1 Sign in .row .col-sm-4 = f . email_field :email , label : \"Email Address\" , placeholder : 'user_name@example.com' .row .col-sm-4 = f . password_field :password = f . submit \"Sign in\" = link_to \"Forgot Password?\" , forgot_password_path # 加入這一行 新增寄信頁面 app/views/forgot_passwords/new.html.haml: %section .forgot_password.container .row .col-sm-10.col-bg-offset-1 = bootstrap_form_tag url : forgot_passwords_path do | f | %header %h1 Forgot Password? %p We will send you an email with a link that you can use to reset your password. .row .col-sm-4 = f . email_field :email , label : \"Email Address\" = f . submit \"Send Email\" 順便一提，這邊使用了 rails-bootstrap-forms 來快速建構具有 twitter bootstrap-style 的表格。 新增確認頁面 app/views/forgot_passwords/confirm.html.haml: %section .confirm_password_reset.container .row .col-sm-10.col-sm-offset-1 %p We have sent an email with instruction to reset your password. 新增修改密碼頁面 app/views/password_resets/show.html.haml: %section .reset_password.container .row .col-sm-10.col-sm-offset-1 = bootstrap_form_tag url : password_resets_path do | f | %header %h1 Reset Your Password .row .col-sm-4 = f . password_field :password , label : \"New Password\" = f . hidden_field :token , value : @token = f . submit \"Reset Password\" 新增 token 已經過期的頁面 app/views/password_resets/expired_token.html.haml: %section .invalid_token.container .row .col-sm-10.col-sm-offset-1 %p Your reset password link is expired. Controllers 新增 ForgotPasswordsController app/controllers/forgot_passwords_controller.rb: class ForgotPasswordsController < ApplicationController def new ; end def create user = User . where ( email : params [ :email ] ) . first if user user . generate_token AppMailer . send_password_reset ( user ) . deliver redirect_to forgot_password_confirmation_path else flash [ :error ] = params [ :email ]. blank? ? \"Email cannot be blank.\" : \"There is no user with that email in the system.\" redirect_to forgot_password_path end end def confirm ; end end 新增 PasswordResetsController app/controllers/password_resets_controller.rb: class PasswordResetsController < ApplicationController def show user = User . where ( token : params [ :id ] ) . first if user @token = params [ :id ] else redirect_to expired_token_path end end def create user = User . where ( token : params [ :token ] ) . first if user user . password = params [ :password ] if user . save user . clear_token flash [ :success ] = \"Your password has been changed. Please sign in.\" else flash [ :error ] = \"Invalid new password. Password did not change.\" end redirect_to sign_in_path else redirect_to expired_token_path end end def expired_token ; end end Models 上面使用的 generate_token 和 clear_token methods 定義在 User class 裡面 app/models/user.rb: class User < ActiveRecord :: Base ... 其他程式碼 ... def generate_token self . update_column ( :token , SecureRandom . urlsafe_base64 ) end def clear_token self . update_column ( :token , nil ) end end Mailer 在 development.rb 和 production.rb 裡面設定 :host 如下 config/environments/development.rb: # Mailer host config . action_mailer . default_url_options = { :host => 'localhost:3000' } config/environments/production.rb: # Mailer host config . action_mailer . default_url_options = { :host => '你的主機' } 然後新增 AppMailer app/mailers/app_mailer.rb: class AppMailer < ActionMailer :: Base default from : ENV [ 'MYFLIX_SMTP_USER_NAME' ] def send_password_reset ( user ) @user = user mail ( to : @user . email , subject : \"Please reset your password\" ) end end MYFLIX_SMTP_USER_NAME 是我們自定的環境變數， 倘若不清楚如何使用環境變數來設定郵件的帳號或密碼， 可參考 這篇文章 。 最後，新增信件內容 app/views/app_mailer/send_password_reset.html.haml: !!! 5 %html ( lang= \"en-US\" ) %body %p Please click on the link below to reset your password: %p = link_to \"Reset My Password\" , password_reset_url ( @user . token )","url":"http://tsaith.github.io/tou-guo-you-jian-yun-xu-shi-yong-zhe-zhong-she-mi-ma.html"},{"tags":"Web","title":"使用單一抽象層撰寫測試","text":"當撰寫測試時，使用單一抽象層的技巧可以讓程式更容易閱讀， 也避免開發者必須將思維在不同抽象層級中切換。 假設我們使用 Capybara 來測試網站的登入流程 require 'spec_helper' feature \"User signs in\" do scenario \"with valid email and password\" do alice = Fabricate ( :user ) # 使用者登入 visit sign_in_path fill_in 'Email' , :with => alice . email fill_in 'Password' , :with => alice . password click_button 'Sign in' expect ( page ) . to have_content alice . full_name end end 在上述的範例中，開發者必須將思緒切換到底層考慮 Capybara 該如何處理欄位的填寫和按鈕， 然後再回到更高階層以預期使用者名稱將會出現在新的頁面。 但我們可以將底層的細節封裝起來， 讓每個步驟儘可能位於同一個抽象層面 feature \"User signs in\" do scenario \"with valid email and password\" do alice = Fabricate ( :user ) # 使用者登入 sign_in ( alice ) expect ( page ) . to have_content alice . full_name end def sign_in ( user ) visit sign_in_path fill_in 'Email' , :with => user . email fill_in 'Password' , :with => user . password click_button 'Sign in' end end 如此一來，開發者在閱讀程式時，就更能專注於思考整體的邏輯， 程式碼所顯示的內聚性也大幅提升; 更多的相關討論可參考 這裡 。","url":"http://tsaith.github.io/shi-yong-dan-yi-chou-xiang-ceng-zhuan-xie-ce-shi.html"},{"tags":"Web","title":"在 RSpec 中使用 Macros","text":"撰寫測試時，常常會遇到不同地方需要做相同或類似的事， 這時候可以考慮將共用的邏輯抽出並寫成 macros， 避免讓相同的程式區塊散佈於各處， 以方便閱讀和日後的維護。 假設我們有份程式用來測試使用者的登入流程，如下 require 'spec_helper' feature \"User signs in\" do scenario \"with valid email and password\" do alice = Fabricate ( :user ) visit sign_in_path fill_in 'Email' , :with => alice . email fill_in 'Password' , :with => alice . password click_button 'Sign in' expect ( page ) . to have_content alice . full_name end end 中間部分的程式碼敘述了使用者的登入步驟; 這時候我們可以將此處抽出並在 spec/support/macros.rb 裡面定義一個新函數 sign_in def sign_in ( a_user = nil ) user = a_user || Fabricate ( :user ) visit sign_in_path fill_in 'Email' , :with => user . email fill_in 'Password' , :with => user . password click_button 'Sign in' end 然後將原先的測試程式改寫如下 require 'spec_helper' feature \"User signs in\" do scenario \"with valid email and password\" do alice = Fabricate ( :user ) sign_in ( alice ) expect ( page ) . to have_content alice . full_name end end 除了程式碼的可讀性明顯提升之外， 日後編寫其他測試時若牽涉到使用者登入， 也只要簡單地引用 sign_in 這個 macro 即可。","url":"http://tsaith.github.io/zai-rspec-zhong-shi-yong-macros.html"},{"tags":"Web","title":"在 RSpec 中使用 shared examples","text":"使用 RSpec 撰寫測試時， 我們可以使用 shared examples 將 常用的測試範例封裝起來，方便隨時調用。 假設我們撰寫了一些測試，如下 require \"spec_helper\" describe VideosController do describe \"GET index\" do it \"sets @categories for authenticated users\" do set_current_user category = Fabricate ( :category ) get :index expect ( assigns ( :categories )) . to eq [ category ] end it \"redirects to the sign in page\" do get :index expect ( response ) . to redirect_to sign_in_path end it \"sets the flash error message\" do get :index expect ( flash [ :error ] ) . to be_present end end describe \"GET show\" do it \"sets @video for authenticated user\" do set_current_user video = Fabricate ( :video ) get :show , id : video . slug expect ( assigns ( :video )) . to eq video end it \"redirects to the sign in page\" do video = Fabricate ( :video ) get :show , id : video . slug expect ( response ) . to redirect_to sign_in_path end it \"sets the flash error message\" do video = Fabricate ( :video ) get :show , id : video . slug expect ( flash [ :error ] ) . to be_present end end end 正如所見， GET index 和 GET show 裡面存在著類似的測試， 我們可以此部分放到 spec/support/shared_examples.rb 裡面 shared_examples \"requires sign in\" do it \"redirects to the sign in page\" do action expect ( response ) . to redirect_to sign_in_path end it \"sets the flash error message\" do action expect ( flash [ :error ] ) . to be_present end end 於是原先的測試程式就可以 refactor 成 require \"spec_helper\" describe VideosController do describe \"GET index\" do it \"sets @categories for authenticated users\" do set_current_user category = Fabricate ( :category ) get :index expect ( assigns ( :categories )) . to eq [ category ] end it_behaves_like \"requires sign in\" do video = Fabricate ( :video ) let ( :action ) { get :index } end end describe \"GET show\" do it \"sets @video for authenticated user\" do set_current_user video = Fabricate ( :video ) get :show , id : video . slug expect ( assigns ( :video )) . to eq video end it_behaves_like \"requires sign in\" do video = Fabricate ( :video ) let ( :action ) { get :show , id : video . slug } end end end 除了程式碼變得簡潔之外， 日後我們也更容易對封裝的部分進行功能的擴充或修改。","url":"http://tsaith.github.io/zai-rspec-zhong-shi-yong-shared-examples.html"},{"tags":"Misc","title":"Bash 中常用的快捷鍵","text":"目前 Mac 預設的 shell 是 Bash，這裡列出一些常用的快捷鍵。 ctrl + a : 將游標移到開頭 ctrl + e : 將游標移到結尾 alt + f : 將游標向前移動一個單字 alt + b : 將游標向後移動一個單字 ctrl + k : 刪除游標後面的所有字元 ctrl + u : 刪除游標前面的所有字元 ctrl + w : 刪除游標前面的一個單字 ctrl + t : 將游標前的兩個字母對調 esc + t : 將游標前的兩個單字對調 tab : 自動完成檔案或目錄名稱 ctrl + d : 刪除游標後的一個字元 ctrl + c : 中斷執行 ctrl + z : 暫停程序並將它丟到背景","url":"http://tsaith.github.io/bash-zhong-chang-yong-de-kuai-jie-jian.html"},{"tags":"Web","title":"好用的 Debug 工具: Pry","text":"開發 Rails 或 Ruby 應用時，我們可以使用 pry 和 pry-nav 來大幅提高 debug 效率。 安裝套件 在 Gemfile 中加入 group : development , : test do gem 'pry' gem 'pry-nav' end 然後執行 bundle 使用方法 在想要 debug 的地方加入 binding.pry，如下 class SessionsController < ApplicationController def new redirect_to home_path if current_user end def create user = User . where ( email : params [ :email ] ) . first if user && user . authenticate ( params [ :password ] ) session [ :user_id ] = user . id binding . pry # 設定中斷點 flash [ :notice ] = \"Your've signed in, enjoy!\" redirect_to home_path else flash [ :error ] = \"Invalid email or password.\" redirect_to sign_in_path end end def destroy session [ :user_id ] = nil redirect_to home_path , notice : \"You are signed out!\" end end 當 server 執行到 binding.pry 所在的地方， 將會暫停並且進入互動模式，這時後就可以開始進行偵錯 From : /Users/ tsaith / projects / myflix / app / controllers / sessions_controller . rb @ line 11 SessionsController #create: 7 : def create 8 : user = User . where ( email : params [ :email ] ) . first 9 : if user && user . authenticate ( params [ :password ] ) 10 : session [ :user_id ] = user . id => 11 : binding . pry 12 : flash [ :notice ] = \"Your've signed in, enjoy!\" 13 : redirect_to home_path 14 : else 15 : flash [ :error ] = \"Invalid email or password.\" 16 : redirect_to sign_in_path 17 : end 18 : end [ 1 ] pry ( #<SessionsController>)> params => { \"utf8\" => \"✓\" , \"authenticity_token\" => \"Is1jphXlmnK8fRfJT2YdJqMcBFTNxuzn1bIum1o9D3U=\" , \"email\" => \"user@gmail.com\" , \"password\" => \"user_password\" , \"commit\" => \"Sign in\" , \"controller\" => \"sessions\" , \"action\" => \"create\" } [ 2 ] pry ( #<SessionsController>)> user.id => 1 [ 3 ] pry ( #<SessionsController>)> next From : /Users/ tsaith / projects / myflix / app / controllers / sessions_controller . rb @ line 12 SessionsController #create: 7 : def create 8 : user = User . where ( email : params [ :email ] ) . first 9 : if user && user . authenticate ( params [ :password ] ) 10 : session [ :user_id ] = user . id 11 : binding . pry => 12 : flash [ :notice ] = \"Your've signed in, enjoy!\" 13 : redirect_to home_path 14 : else 15 : flash [ :error ] = \"Invalid email or password.\" 16 : redirect_to sign_in_path 17 : end 18 : end [ 1 ] pry ( #<SessionsController>)> 倘若希望離開偵錯模式，請執行 Ctrl + d 。 最後，如果想對常用的命令新增 alias 可以在 ~/.pryrc 裡面定義 Pry . commands . alias_command 'c' , 'continue' Pry . commands . alias_command 's' , 'step' Pry . commands . alias_command 'n' , 'next'","url":"http://tsaith.github.io/hao-yong-de-debug-gong-ju-pry.html"},{"tags":"Web","title":"快速啟動 rails: pow","text":"許多 Rails 開發者應該都有這樣的經驗， 每次開發專案前總是得先在終端機執行 rails server 才能啟動網站， 這樣實在有點麻煩; Basecamp 因此而開發了一個免費工具 Pow 可以簡單地為我們解決這個困擾。 安裝 Pow 在終端機下執行 $ curl get.pow.cx | sh 使用方法 進入 ~/.pow 目錄，然後創造一個專案的連結即可。 例如，假設我們有一個專案 ~/projects/myflix， 那麼可以執行下面的命令來創造對應的連結 $ cd ~/.pow $ ln -s ~/projects/myflix 現在， 只要將瀏覽器連到 http://myflix.dev 就能看到運行的網站。 使用 RVM 因為 pow 預設只有支援 rbenv ， 所以 rvm 的使用者需要額外地在專案下新增 .powenv 並加入下面的內容，才能讓 pow 正常工作。 if [ -z \" ${ rvm_path :- } \" ] && [ -x \" ${ HOME :- } /.rvm/bin/rvm\" ] then rvm_path = \" ${ HOME :- } /.rvm\" fi if [ -z \" ${ rvm_path :- } \" ] && [ -x \"/usr/local/rvm/bin/rvm\" ] then rvm_path = \"/usr/local/rvm\" fi # load environment of current project ruby if [ -n \" ${ rvm_path :- } \" ] && [ -x \" ${ rvm_path :- } /bin/rvm\" ] && rvm_project_environment = ` \" ${ rvm_path :- } /bin/rvm\" . do rvm env --path 2>/dev/null ` && [ -n \" ${ rvm_project_environment :- } \" ] && [ -s \" ${ rvm_project_environment :- } \" ] then echo \"RVM loading: ${ rvm_project_environment :- } \" \\. \" ${ rvm_project_environment :- } \" else echo \"RVM project not found at: $PWD \" fi 更方便地使用 Pow Powder 可以讓 pow 的使用變得更加方便。 安裝套件 $ gem install powder 這裡列出一些常用的操作: 連結當前目錄到 ~/.pow/<當前目錄> $ power link 在瀏覽器開啓專案 $ powder open 查看 .powenv 的內容 $ powder env 開啓 debug shell $ power debug 重開 app $ powder restart","url":"http://tsaith.github.io/kuai-su-qi-dong-rails-pow.html"},{"tags":"Web","title":"使用 RSpec 寫 Feature Tests","text":"在開發 Rails 專案時，我們可使用 Feature Tests 來模擬使用者在應用程式中的操作流程; 這裡將介紹如何使用 RSpec 搭配 Capybara 來撰寫這方面的測試。 安裝套件 在 Gemfile 加入 gem 'capybara' 然後執行 bundle 安裝 Capybara。 假使安裝套件時遇到 'An error occurred while installing nokogiri' 這樣的錯誤訊息 Gem::Ext::BuildError: ERROR: Failed to build gem native extension. /Users/tsaith/.rvm/rubies/ruby-2.1.1/bin/ruby -r ./siteconf20141220-15553-1vqn6mc.rb extconf.rb checking if the C compiler accepts ... yes checking if the C compiler accepts -Wno-error=unused-command-line-argument-hard-error-in-future... no Building nokogiri using packaged libraries. checking for iconv... yes ************************************************************************ IMPORTANT NOTICE: Buidling Nokogiri with a packaged version of libxml2-2.9.2 with the following patches applied: - 0001-Revert-Missing-initialization-for-the-catalog-module.patch - 0002-Fix-missing-entities-after-CVE-2014-3660-fix.patch Team Nokogiri will keep on doing their best to provide security updates in a timely manner, but if this is a concern for you and want to use the system library instead; abort this installation process and reinstall nokogiri as follows: gem install nokogiri -- --use-system-libraries [--with-xml2-config=/path/to/xml2-config] [--with-xslt-config=/path/to/xslt-config] If you are using Bundler, tell it to use the option: bundle config build.nokogiri --use-system-libraries bundle install Note, however, that nokogiri is not fully compatible with arbitrary versions of libxml2 provided by OS/package vendors. ************************************************************************ Extracting libxml2-2.9.2.tar.gz into tmp/x86_64-apple-darwin12.5.0/ports/libxml2/2.9.2... OK Running patch with /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/nokogiri-1.6.5/ports/patches/libxml2/0001-Revert-Missing-initialization-for-the-catalog-module.patch... Running 'patch' for libxml2 2.9.2... OK Running patch with /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/nokogiri-1.6.5/ports/patches/libxml2/0002-Fix-missing-entities-after-CVE-2014-3660-fix.patch... Running 'patch' for libxml2 2.9.2... OK Running 'configure' for libxml2 2.9.2... ERROR, review '/Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/nokogiri-1.6.5/ext/nokogiri/tmp/x86_64-apple-darwin12.5.0/ports/libxml2/2.9.2/configure.log' to see what happened. *** extconf.rb failed *** Could not create Makefile due to some reason, probably lack of necessary libraries and/or headers. Check the mkmf.log file for more details. You may need configuration options. Provided configuration options: --with-opt-dir --without-opt-dir --with-opt-include --without-opt-include= ${ opt - dir } /include --with-opt-lib --without-opt-lib= ${ opt - dir } /lib --with-make-prog --without-make-prog --srcdir=. --curdir --ruby=/Users/tsaith/.rvm/rubies/ruby-2.1.1/bin/ruby --help --clean --use-system-libraries --enable-static --disable-static --with-zlib-dir --without-zlib-dir --with-zlib-include --without-zlib-include= ${ zlib - dir } /include --with-zlib-lib --without-zlib-lib= ${ zlib - dir } /lib --enable-cross-build --disable-cross-build /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/mini_portile-0.6.1/lib/mini_portile.rb:279:in `block in execute': Failed to complete configure task (RuntimeError) from /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/mini_portile-0.6.1/lib/mini_portile.rb:271:in `chdir' from /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/mini_portile-0.6.1/lib/mini_portile.rb:271:in `execute' from /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/mini_portile-0.6.1/lib/mini_portile.rb:66:in `configure' from /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/mini_portile-0.6.1/lib/mini_portile.rb:109:in `cook' from extconf.rb:268:in `block in process_recipe' from extconf.rb:167:in `tap' from extconf.rb:167:in `process_recipe' from extconf.rb:455:in ` <main> ' extconf failed, exit code 1 Gem files will remain installed in /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/gems/nokogiri-1.6.5 for inspection. Results logged to /Users/tsaith/.rvm/gems/ruby-2.1.1@myflix/extensions/x86_64-darwin-12/2.1.0-static/nokogiri-1.6.5/gem_make.out An error occurred while installing nokogiri (1.6.5), and Bundler cannot continue. Make sure that `gem install nokogiri -v '1.6.5'` succeeds before bundling. 可以試著指定系統內建的函式庫來安裝 Nokogiri bundle config build.nokogiri --use-system-libraries 然後再執行一次 bundle 。 設定 spec_helper.rb 在 spec/spec_helper.rb 裡面加入 require 'capybara/rails' # This file is copied to spec/ when you run 'rails generate rspec:install' ENV [ \"RAILS_ENV\" ] ||= 'test' require File . expand_path ( \"../../config/environment\" , __FILE__ ) require 'rspec/rails' require 'capybara/rails' 編寫測試 假設我們現在想要模擬使用者的登入流程， 請新增檔案 spec/features/user_signs_in_spec.rb 並加入內容如下 require 'spec_helper' feature \"User signs in\" do scenario \"with valid email and password\" do alice = Fabricate ( :user ) # 宣告使用者 visit sign_in_path # 訪問登入網頁 fill_in 'Email' , :with => alice . email # 填寫 Email fill_in 'Password' , :with => alice . password # 填寫 Password click_button 'Sign in' # 按下 Sign in 按鈕 expect ( page ) . to have_content alice . full_name # 預期網頁的內容會出現使用者的名字 end end 上面的 feature 和 scenario 其意義等同於 RSpec 中的 describe ..., :type => :feature 和 it ; Relish 提供了豐富的語法介紹。 最後，執行 rspec 即可看到測試結果。","url":"http://tsaith.github.io/shi-yong-rspec-xie-feature-tests.html"},{"tags":"Web","title":"使用 RSpec 撰寫 Functional Tests","text":"在開發 Rails 專案時，我們可以撰寫 Functional Tests 來測試 controller 的功能是否正常工作; 例如，如果想測試使用者的登入與登出， 就可以在 spec/controllers/ 下面新增一個檔案 sessions_controller_spec.rb，內容如下 require \"spec_helper\" describe SessionsController do let ( :user ) { Fabricate ( :user ) } describe \"GET new\" do it \"redirects to the home page for authenticated users\" do session [ :user_id ] = user . id get :new expect ( response ) . to redirect_to home_path end end describe \"POST create\" do context \"with valid credentials\" do before do post :create , email : user . email , password : user . password end it \"puts the signed in user in the session\" do expect ( session [ :user_id ] ) . to eq user . id end it \"redirects to the home page\" do expect ( response ) . to redirect_to home_path end it \"sets the notice\" do expect ( flash [ :notice ] ) . not_to be_blank end end context \"with invalid credentials\" do before do post :create , email : user . email , password : user . password + \"sadsafds\" end it \"does not put the signed in user in the session\" do expect ( session [ :user_id ] ) . to be_nil end it \"redirects to the sign in page\" do expect ( response ) . to redirect_to sign_in_path end it \"sets the error message\" do expect ( flash [ :error ] ) . not_to be_blank end end end describe \"GET destroy\" do before do session [ :user_id ] = user . id get :destroy end it \"clears the session for the user\" do expect ( session [ :user_id ] ) . to be_nil end it \"redirects to the home page\" do expect ( response ) . to redirect_to home_path end it \"sets the notice\" do expect ( flash [ :notice ] ) . not_to be_blank end end end 在上面的範例中，我們測試了 new 和 create 以及 destroy 三個動作，並使用 Fabrication 來簡化產生 User 物件的過程; 其對應的程式碼則位於 spec/fabricators/ 下面的 user_fabricator.rb Fabricator ( :user ) do email { Faker :: Internet . email } password { Faker :: Internet . password } full_name { Faker :: Name . name } end 在 user fabricator 裡面，進一步使用了 Faker 來自動產生 email 或 password 欄位的值。 編寫好程式後，執行 rspec 就能看到測試結果。","url":"http://tsaith.github.io/shi-yong-rspec-zhuan-xie-functional-tests.html"},{"tags":"Web","title":"使用 RSpec 撰寫 Unit Tests","text":"我們可以使用單元測試來檢查模型的屬性和自定方法是否正常運作; 假設有個 Category model，內容如下 class Category < ActiveRecord :: Base has_many :videos , -> { order ( 'created_at DESC' ) } validates :name , presence : true , uniqueness : true def recent_videos videos . first ( 6 ) end end 那麼對應的測試程式 spec/models/category_spec.rb 其內容可以撰寫如下 require 'spec_helper' require 'shoulda/matchers' describe Category do it { is_expected . to have_many :videos } it { is_expected . to validate_presence_of :name } it { is_expected . to validate_uniqueness_of :name } describe \"#recent_videos\" do let ( :category ) { Category . create! ( name : \"Game\" )} subject { category . recent_videos } it \"returns an empty array if the category does not have any videos\" do expect ( subject ) . to eq [] end it \"returns all videos if there are less than 6 videos\" do 1 . upto ( 5 ) { | index | category . videos . create ( title : \"FF #{ index } \" , description : \"Final Fantasy\" ) } expect ( subject . count ) . to eq 5 end it \"returns 6 videos if there are more than 6 videos\" do 1 . upto ( 7 ) { | index | category . videos . create ( title : \"FF #{ index } \" , description : \"Final Fantasy\" ) } expect ( subject . count ) . to eq 6 end it \"returns the videos in the reverse order by created_at\" do ff = category . videos . create ( title : \"FF\" , description : \"Final Fantasy\" , created_at : 2 . days . ago ) dq = category . videos . create ( title : \"DQ\" , description : \"Dragon Quest\" , created_at : 1 . day . ago ) expect ( subject ) . to eq [ dq , ff ] end end end","url":"http://tsaith.github.io/shi-yong-rspec-zhuan-xie-unit-tests.html"},{"tags":"Web","title":"使用 RSpec 做自動測試","text":"RSpec 是一套專為 Ruby 設計的 BDD (Behavior Deriven Development) 測試框架， 基於它所撰寫出的測試程式有著相當高的可讀性， 感覺就像是在閱讀產品的規格書。 安裝套件 在專案的 Gemfile 中加入 rspec-rails 的 gem，如下 group : development , : test do gem 'rspec-rails' , '2.99' end 除了 RSpec 之外， 因為 shoulda-matchers ， 額外提供了許多有用的測試函式，建議一併安裝。 group : test do gem 'shoulda-matchers' , '2.7.0' , require : false end 編輯完 Gemfile 後，請執行 bundle 進行套件安裝。 最後，再執行 rails g rspec:install 以產生 RSpec 運作所需的相關檔案。 設定 spec_helper.rb 在 spec/spec_helper.rb 檔案的開頭加入以下內容 ENV [ \"RAILS_ENV\" ] ||= 'test' require File . expand_path ( \"../../config/environment\" , __FILE__ ) require 'rspec/rails' 撰寫測試 假設我們在 app/models/video.rb 有個 Video model， 如下 class Video < ActiveRecord :: Base belongs_to :category validates_presence_of :title , :description end 這個 Video model 屬於 Category 並且要求在產生物件時需要檢驗 title 和 description 已經存在， 那麼對應的測試檔案 spec/models/video_spec.rb 的內容可以寫成 require 'spec_helper' require 'shoulda/matchers' describe Video do it { should belong_to :category } it { should validate_presence_of :title } it { should validate_presence_of :description } end 寫好測試程式後，請在專案目錄下執行 rspec spec/models/video_spec.rb 就能看到測試結果。 倘若要一次跑多個測試，請直接執行 rspec ， 就會跑放在 spec/ 下面的所有測試程式。","url":"http://tsaith.github.io/shi-yong-rspec-zuo-zi-dong-ce-shi.html"},{"tags":"Misc","title":"iTerm2 中好用的設定","text":"iTerm2 被設計用來取代 Mac 內建的 Terminal; 這裡記錄了我個人的一些偏好設定。 偏好設定 以下的偏好都可以在 Preference 裡面進行設定 開啟新分頁時，自動進入前一個 session 的所在目錄 Profile -> General -> Login shell Profile -> General -> Reuse previous session's directory 設定主題風格(例如背景顏色...等) Profile -> Colors -> Load Presets... -> Tango Dark 改變字型和大小 Profile -> Text -> Change Font 讓 alt/option key 可以在 Emacs 中正常工作 Profile -> Keys -> Left option key acts as: +Esc Profile -> Keys -> Right option key acts as: +Esc 使用 alt + Space 快速隱藏/顯示 iTerm2 Profile -> Keys -> Show/hide iTerm2 with a system-wide hotkey","url":"http://tsaith.github.io/iterm2-zhong-hao-yong-de-she-ding.html"},{"tags":"Web","title":"實作簡易的搜尋功能","text":"在電子商務中，商品的搜尋是很重要的一環， 這裡將介紹如何實作簡易的搜尋功能。 倘若我們現在希望開發一個搜尋影片的功能; 假設影片的類別名稱是 Video， 首先在 config/routes.rb 裡面加入 search 的路徑 resources :videos , only : [ :show ] do collection do get 'search' , to : 'videos#search' end end 接著在 app/controllers/videos_controller.rb 裡面加入 search action def search @videos = Video . search_by_title ( params [ 'search_term' ] ) end 然後在 app/models/video.rb 裡面新增 search_by_title 方法 def self . search_by_title ( str ) return [] if str . blank? where ( \"title LIKE ?\" , \"% #{ str } %\" ) . order ( \"created_at DESC\" ) end 這裡使用 Haml 來撰寫 views; 若想為網站的 header 加入搜尋欄位， 請在 app/views/shared/_header.html.haml 裡面加入 = form_tag search_videos_path , method : 'get' , class : 'col-md-5 navbar-form' do = text_field_tag :search_term , params [ 'search_term' ] ||= '' , class : 'form-control' , placeholder : \"Search for videos here\" = submit_tag 'Search' , class : 'btn btn-default' 最後，新增搜尋頁面 app/views/videos/search.html.haml - @videos . each do | video | .video.ul .li #{ video . title } .li = image_tag ( video . cover_image_url , size : cover_image_size )","url":"http://tsaith.github.io/shi-zuo-jian-yi-de-sou-xun-gong-neng.html"},{"tags":"Web","title":"安全地設定 Rails 郵件密碼","text":"將密碼寫進程式通常不是個好主意，因為當我們使用版本控制系統(例如 git) 儲存程式時，密碼也將會被一併存入，如果是開源的專案， 那麼任意人都可以取得這資訊;為避免此問題， 我們可以使用環境變數讓 Rails 較安全地存取密碼資訊。 設定郵件密碼 這裡以 config/environments/ 下的 production.rb 為例子， 在 password 這裡，我們可以使用 ENV 來讀取系統的環境變數。 # Delivery method of mailer config . action_mailer . delivery_method = :smtp # Settings of the mailer config . action_mailer . smtp_settings = { address : \"smtp.gmail.com\" , port : 587 , domain : \"gmail.com\" , authentication : \"plain\" , user_name : thtsai . demo @gmail . com , password : ENV [ 'SMTP_PASSWORD' ] , enable_starttls_auto : true } 設定環境變數 若開發環境是 Mac，可在 ~/.profile 裡面加入 export SMTP_PASSWORD='My password' 當專案上傳到遠端主機後，記得將密碼寫到遠端的環境變數; 下面以 Heroku 為例 heroku config:add SMTP_PASSWORD='My password' 這樣一來，Rails 就能通過環境變數來取得密碼資訊。","url":"http://tsaith.github.io/an-quan-di-she-ding-rails-you-jian-mi-ma.html"},{"tags":"Web","title":"在 Rails 中使用 PostgresSQL","text":"PostgreSQL 是目前相當受歡迎的一套開源資料庫， 下面將說明如何在 Rails 中使用它。 安裝套件 如若開發環境是 Mac 的話，請執行下列步驟 下載 Postgres.app ，放到 /Applications/ 資料夾下 在 ~/.profile 加入 export PATH= $ PATH :/Applications/Postgres.app/Contents/Versions/9.3/bin export PGHOST=localhost (假設版本號是 9.3) 設定 Rails 資料庫 編輯 config/database.yml 內容如下 development : adapter : postgresql encoding : unicode database : myflix_development pool : 5 username : YOUR_USERNAME password : YOUR_PASSWORD test : adapter : postgresql encoding : unicode database : myflix_test pool : 5 username : YOUR_USERNAME password : YOUR_PASSWORD production : adapter : postgresql encoding : unicode database : myflix_test pool : 5 username : YOUR_USERNAME password : YOUR_PASSWORD 接著在 Gemfile 中加入 gem 'pg' 然後執行 bundle 完成上述步驟後，我們就可以在 Rails 中存取 PostgreSQL 資料庫。 常用指令 這裡列出一些 PostgreSQL 常用的指令 建立資料庫: createdb db_name 刪除資料庫: dropdb db_name 列出所有資料庫: psql -l PostgreSQL 的內建命令: 列出所有資料庫: \\l 連接資料庫: \\c db_name 顯示所有 tables: \\d 新增資料庫: DROP DATABASE db_name; 刪除資料庫: DROP DATABASE db_name; 建立 table: CREATE TABLE db_table(id int, text VARCHAR(50)); 刪除 table: DROP TABLE db_table; 查詢記錄: SELECT * FROM db_table WHERE id = 1; 插入一筆記錄: INSERT INTO db_table(id, text) VALUES(1, 'A new record'); 更新一筆記錄: UPDATE db_table SET text = 'str' WHERE id = 1; 刪除一筆記錄: DELETE FROM test WHERE id = 1;","url":"http://tsaith.github.io/zai-rails-zhong-shi-yong-postgressql.html"},{"tags":"Web","title":"在 Rails 使用 gmail 發送郵件","text":"建構網站時，發送信件往往是重要的一項功能， 例如，當使用者註冊或變更個人設定時， 這時候網站可以發送確認信函以提高安全性; 這裡將介紹如何在 Rails 中使用 gmail 發送郵件。 設定郵件環境 編輯 config/environments/ 下的 development.rb 和 production.rb 兩個檔案， 設定 delivery_method 和 smtp_settings 如下 # Don't care if the mailer can't send. config . action_mailer . raise_delivery_errors = false # Delivery method of mailer config . action_mailer . delivery_method = :smtp # Settings of the mailer config . action_mailer . smtp_settings = { address : \"smtp.gmail.com\" , port : 587 , domain : \"gmail.com\" , authentication : \"plain\" , user_name : \"example@gmail.com\" , password : \"12345678\" , enable_starttls_auto : true } 產生 Mailer 新增檔案 app/mailers/user_mailer.rb， 在 UserMailer class 中定義了一個 welcome_email method class UserMailer < ActionMailer :: Base default from : 你 / 妳的郵件地址 def welcome_email ( user ) @user = user mail ( to : @user . email , subject : \"You have sucessfully registered.\" ) end end 信件的 views 接著，新增資料夾 app/views/user_mailer/， 並在裡面加入兩個檔案 welcome_email.html.erb 和 welcome_email.text.erb。 .html.erb 結尾的檔案支援 HTML 格式 <! DOCTYPE html> <html> <body> <p> You have successfully registered. </p> </body> </html> 而 .text.erb 結尾的檔案支援純文字格式 You have successfully registered. 設定 gmail 帳號的安全性 因為 gmail 預設對應用程式登入的安全性要求比較高， 會擋掉單純使用密碼登入的機制; 所以我們另外得在自己的 gmail account 中啟用安全性較低的應用程式存取權 測試郵件發送 使用 rails console 測試郵件的發送 $ rails console Loading development environment ( Rails 4.0.0 ) 2.1.1 :001 > UserMailer.welcome_email ( User.last ) .deliver 如果 welcome_email 工作正常， 當使用者註冊成功後，就可以用它來自動發送歡迎信件。 備註: 每次修改 config/environments/development.rb 後， 記得重新啓動 rails server 讓新設定生效。","url":"http://tsaith.github.io/zai-rails-shi-yong-gmail-fa-song-you-jian.html"},{"tags":"Web","title":"在 Rails 中使用 module","text":"在開發 Rails 時，我們常常遇到一種情況， 不同的物件模型需要用到相同的功能， 這時候可以考慮將這功能包裝成一個模組， 以方便調用。 設定搜尋路徑 首先，在 config/application.rb 裡面加入 config.autoload_paths += %W(#{config.root}/lib) 設定 lib 為 modules 的存放路徑。 require File . expand_path ( '../boot' , __FILE__ ) require 'rails/all' # Require the gems listed in Gemfile, including any gems # you've limited to :test, :development, or :production. Bundler . require ( :default , Rails . env ) module PostitTemplate class Application < Rails :: Application # Settings in config/environments/* take precedence over those specified here. # Application configuration should go into files in config/initializers # -- all .rb files in that directory are automatically loaded. # Module paths config . autoload_paths += %W( #{ config . root } /lib) # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone. # Run \"rake -D time\" for a list of tasks for finding time zone names. Default is UTC. config . time_zone = 'Taipei' # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded. # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s] # config.i18n.default_locale = :de # Tealeaf note: Bootstrap sass gem addition config . assets . precompile += %w(*.png *.jpg *.jpeg *.gif) end end 包裝模組 然後將模組的檔案放到 lib/ 下面; 請特別注意， 檔名和模組名稱需要一致，舉例來說， 如果檔名為 voteable_th.rb，那麼模組名稱就是 VoteableTh， 不然，Rails 會找不到這模組(至少在 4.1.6 以下的版本還是如此)。 而這裡的 voteable_th.rb 內容如下 module VoteableTh extend ActiveSupport :: Concern included do has_many :votes , as : :voteable , :dependent => :destroy end def total_votes up_votes - down_votes end def up_votes self . votes . where ( vote : true ) . size end def down_votes self . votes . where ( vote : false ) . size end end 調用模組 最後，我們可以直接在物件模型中透過 include 來使用模組，如下 class Post < ActiveRecord :: Base include VoteableTh belongs_to :creator , class_name : \"User\" , foreign_key : \"user_id\" has_many :comments , :dependent => :destroy validates :title , presence : true , length : { minimum : 3 } validates :description , presence : true end","url":"http://tsaith.github.io/zai-rails-zhong-shi-yong-module.html"},{"tags":"Web","title":"製作和發佈 gem","text":"當我們在某個專案中完成了某個功能並且模組化後， 倘若其他專案也需要同樣功能， 或是希望分享給開源社群時， 這時候就可以將它製作成 gem 方便大家使用。 製作過程 新增一個 gem 的資料夾，假設名稱為 voteable-gem 進入資料夾中，新增 lib 資料夾，並將寫好的程式檔案放進 lib/ $ ls lib voteable_th.rb 在上面的範例中，voteable_th.rb 是一個用來投票的模組，內容如下 module VoteableTh extend ActiveSupport :: Concern included do has_many :votes , as : :voteable , :dependent => :destroy end def total_votes up_votes - down_votes end def up_votes self . votes . where ( vote : true ) . size end def down_votes self . votes . where ( vote : false ) . size end end 在 voteable-gem 資料夾下新增檔案 voteable.gemspec 來定義 gem specification，內容如下 Gem :: Specification . new do | s | s . name = 'voteable_th' # gem 的名字 s . version = '0.0.0' # 版本號碼 s . summary = \"A voting gem\" s . description = \"A voting gem for Rails\" s . authors = [ \"Tsung-Hua Tsai\" ] s . email = 'tsai.tsunghua@gmail.com' s . files = [ \"lib/voteable_th.rb\" ] # 檔案位置 s . homepage = 'http://tsaith.github.io/' s . license = 'MIT' end 使用 gem build 來製作 gem $ gem build voteable.gemspec Successfully built RubyGem Name: voteable_th Version: 0.0.1 File: voteable_th-0.0.0.gem 發佈到開源社群 到 Rubygems.org 上面 註冊 使用 gem push 將 gem 發佈到 Rubygems.org $ gem push voteable_th-0.0.0.gem Pushing gem to https://rubygems.org... Successfully registered gem: voteable_th ( 0.0.0 ) 倘若一切順利，恭喜你已經成功地將 gem 發佈出去。 如果要查詢剛剛發佈的 gem 請執行 $ gem search -r voteable_th *** REMOTE GEMS *** voteable_th ( 0.0.0 ) 假設發現已發佈的 gem 有嚴重 bug 時， 可使用 gem yank 來避免以後的使用者下載 $ gem yank voteable_th -v 0.0.0 Yanking gem from https://rubygems.org... Successfully yanked gem: voteable_th ( 0.0.0 ) 倘若想回復上面的動作，則執行 $ gem yank voteable_th -v 0.0.0 --undo Unyanking gem from https://rubygems.org... Successfully unyanked gem: voteable_th ( 0.0.0 ) 其他進階的操作說明可參考 RubyGems Guides 。","url":"http://tsaith.github.io/zhi-zuo-he-fa-bu-gem.html"},{"tags":"Web","title":"在 Rails 中使用 Ajax","text":"假設有一個投票功能，每次按文章左側的上下箭頭可以表示贊成或反對， 但我們不希望使用者每次投票時，瀏覽器都必須重新載入頁面， 這時候可以使用 Ajax 技術來實現。 設定 routes 對應上面的範例，我們先設定 config/routes.rb， 因為投票動作本身沒有 view， 所以將動作設定為 post resources :posts do member do post :vote end end 設定 view 接著開啟 html 檔案 app/views/posts/_post.html.erb 加入 remote: true ，來呼叫 javascript 動作 < div class = \"row\" > < div id = \"post_vote_error_<%= post.to_param %>\" class = \"alert alert-error\" style = \"display:none\" > You can only vote on a post once . < /div> <div class=\"span0 well text-center\"> <%= link_to vote_post_path(post, vote: true), method: 'post', remote: true do %> <i class='icon-arrow-up'></i > < % end %> <br/> < span id = \"post_<%= post.slug %>_votes\" >< %= post.total_votes %> votes </span> <br/> <%= link_to vote_post_path ( post , vote : false ), method : 'post' , remote : true do %> <i class='icon-arrow-down'> < /i> <% end %> </ div > < /div> ... 然後在同個資料夾下新增檔案 app/views/posts/vote.js.erb，於其中撰寫 javascript 的工作邏輯; 若投票成功，就更新投票數，如果失敗，則顯示錯誤訊息。 < % if @vote . valid? %> $('#post_<%= @post.slug %> _votes ').html(' < %= @post.total_votes %> votes'); <% else %> $('#post_vote_error_<%= @post . to_param %>').show().fadeOut(3000); <% end %> 因為在投票的物件模型中，使用了 validates_uniqueness_of 來限定每位使用者只能投票一次 class Vote < ActiveRecord :: Base belongs_to :user belongs_to :voteable , polymorphic : true validates_uniqueness_of :user , scope : [ :voteable_type , :voteable_id ] end 所以當重複投票時，將產生投票失敗， javascript 將會搜尋 html 中 id 為 post_vote_error_<%= @post.to_param %> 的元件並顯示，如下 設定 controller 最後，我們需要在 controller 的 vote method 中使用 respond_to 來分別撰寫對應 html 和 javascript 的處理 def vote @vote = Vote . create ( voteable : @post , creator : current_user , vote : params [ :vote ] ) respond_to do | format | format . html do if @vote . valid? flash [ :notice ] = \"Your vote is counted.\" else flash [ :error ] = \"You can only vote on a post once.\" end redirect_to :back end format . js end end","url":"http://tsaith.github.io/zai-rails-zhong-shi-yong-ajax.html"},{"tags":"Web","title":"設定 polymorphic association","text":"假設我們有個布告版，上面可以張貼文章和留言， 如果我們希望新增一個功能讓使用者可以對文章或留言進行投票， 這時候可以透過 polymorphic association 來描述 Vote 和 Post 以及 Comment 三個物件模型之間的關係。 新增 Table 首先，在資料庫中新增一個 votes table 來儲存投票資訊; 在 votes 中， voteable_type 和 voteable_id 分別代表被投票物件的名稱和 id。 新增完成後，查看 db/schema.rb 如下 create_table \"votes\" , force : true do | t | t . boolean \"vote\" t . integer \"user_id\" t . string \"voteable_type\" t . integer \"voteable_id\" t . datetime \"created_at\" t . datetime \"updated_at\" end create_table \"posts\" , force : true do | t | t . string \"url\" t . string \"title\" t . text \"description\" t . integer \"user_id\" t . datetime \"created_at\" t . datetime \"updated_at\" end create_table \"comments\" , force : true do | t | t . text \"body\" t . integer \"user_id\" t . integer \"post_id\" t . datetime \"created_at\" t . datetime \"updated_at\" end 設定 Models 新增檔案 app/models/vote.rb， 使用 polymorphic: true 來指定 voteable 是 polymorphic。 此外，我們進一步地規定每位使用者只能對每個 voteable 物件進行一次投票。 app/models/vote.rb: class Vote < ActiveRecord :: Base belongs_to :user belongs_to :voteable , polymorphic : true validates_uniqueness_of :user , scope : [ :voteable_type , :voteable_id ] end 接著在 post.rb 和 comment.rb 中加入 has_many :votes, as: :voteable 來指定每個 post 和 comment 都可以擁有多個投票。 app/models/post.rb: class Post < ActiveRecord :: Base belongs_to :user has_many :comments , :dependent => :destroy has_many :votes , as : :voteable validates :title , presence : true validates :description , presence : true end app/models/comment.rb: class Comment < ActiveRecord :: Base belongs_to :user belongs_to :post has_many :votes , as : :voteable validates :body , presence : true validates :user_id , presence : true validates :post_id , presence : true end 設定好模型之間的關係後， 我們就可以開始在 Controllers 和 Views 中使用這些物件進行開發。","url":"http://tsaith.github.io/she-ding-polymorphic-association.html"},{"tags":"Web","title":"部署專案到 Heroku","text":"Heroku 是個相當受歡迎的雲端平台， 為開發者建構了網站運行所需要的環境， 原則上，使用者只要將自己的應用程式部署上去便可直接運行; 目前，它還提供了免費試用的方案，相當適合學生練習實作。 而使用方法簡介如下 先到 Keroku 官網進行 註冊 註冊後，登入官網然後下載 Heroku toolbelt 並且安裝 打開終端機，執行 heroku login 來登入使用者資訊並上傳 public ssh key 在專案下，執行 heroku create $ heroku create Creating agile-sea-7701... done , stack is cedar-14 https://agile-sea-7701.herokuapp.com/ | git@heroku.com:agile-sea-7701.git Git remote heroku added $ git remote heroku origin 執行 git push heroku master 將專案部署到Heroku上， 部署結束後，會顯示專案對應的網路位址 執行 heroku ps:scale web=1 確認至少有一個 instance 在運行 $ heroku ps:scale web = 1 Scaling dynos... done , now running web at 1:1X. 執行 heroku run rake db:migrate 在 Heroku 上進行 database migration 如果希望對 app 重新命名可以執行 heroku apps:rename 新名稱 如果一切順利，我們現在就可以執行 heroku open 讓瀏覽器訪問網站的首頁 Good Luck!","url":"http://tsaith.github.io/bu-shu-zhuan-an-dao-heroku.html"},{"tags":"Web","title":"在 Rails 實作驗證機制","text":"在網路應用中，使用者驗證是一項常見的重要功能， 雖然使用現成的 gem (例如 Devise )， 可以快速實現出功能原型，但是卻會因為對套件內部架構的不熟悉， 而無法輕易修改或擴充新功能; 所以，這裡將敘述如何單純地使用 Rails 的內建功能來實作驗證機制， 希望讓讀者對其中的工作原理有透徹的認識。 安裝 bcrypt-ruby 為了支援密碼驗證，我們先在 Gemfile 中加入 gem 'bcrypt-ruby', '3.0.1' 然後執行 bundle 進行套件安裝。 設定資料庫 假設我們的使用者資料表名稱為 users， 先在 users 中新增一個 password_digest 的字串欄位， 然後在 db/schema 確認如下 create_table \"users\" , force : true do | t | t . string \"username\" t . datetime \"created_at\" t . datetime \"updated_at\" t . string \"password_digest\" end 設定 routes 在 config/routes.rb 中加入 login 和 logout 的路徑，如下 get 'login' , to : 'sessions#new' post 'login' , to : 'sessions#create' get 'logout' , to : 'sessions#destroy' 設定 model 編輯 User model，加入 has_secure_password 來提供密碼驗證的功能; 在這裡，我關掉 has_secure_password 預設的驗證機制，然後再手動地指定 使用者名稱和密碼的驗證，以確定所有行為都在我們的掌握中。 class User < ActiveRecord :: Base has_secure_password validations : false validates :username , presence : true , uniqueness : true validates :password , presence : true , on : :create , length : { minimum : 5 } end 設定 view 新增 app/views/sessions/new.html.erb ，內容如下 < %= render 'shared/content_title', title: 'Please log in' %> <div class= 'well' > < %= form_tag '/login' do %> <div class= 'control-group' > < %= label_tag :username %> <%= text_field_tag :username , params [ :username ] || '' %> </div> < div > < %= label_tag :password %> <%= password_field_tag :password , params [ :password ] || '' %> </div> <%= submit_tag \"Login\" , class : 'btn btn-success' %> <% end %> < /div> 在這個登入表單中，使用者被要求輸入 username 和 password。 設定 controller 新增 app/controllers/sessions_controller.rb，內容如下 class SessionsController < ApplicationController def new end def create user = User . find_by ( username : params [ :username ] ) if user && user . authenticate ( params [ :password ] ) session [ :user_id ] = user . id flash [ :notice ] = \"Your've logged in!\" redirect_to root_path else flash [ :error ] = \"There's something wrong with username or password\" redirect_to register_path end end def destroy session [ :user_id ] = nil flash [ :notice ] = \"You've logged out!\" redirect_to root_path end end 在 create 中， 我們使用 user.authenticate(params[:password]) 來驗證使用者密碼是否正確， 如果是，再透過 session[:user_id] 來貯存 user id; 而在 destroy 裡面， 則使用 session[:user_id] = nil 來清除 user id。 最後，我們可以在 app/controllers/application_controller.rb 加入三個常用的方法，方便隨時調用。 class ApplicationController < ActionController :: Base # Prevent CSRF attacks by raising an exception. # For APIs, you may want to use :null_session instead. protect_from_forgery with : :exception helper_method :current_user , :logged_in? def current_user @current_user ||= User . find ( session [ :user_id ] ) if session [ :user_id ] end def logged_in? !! current_user end def require_user unless logged_in? flash [ :error ] = \"Must be logged in to do that\" redirect_to root_path end end end current_user : 回傳目前的使用者 logged_in? : 是否已登入? require_user : 檢查是否已登入，如果沒有登入，則導向根路徑 倘若一切順利，我們已經從無到有實作了使用者驗證機制， 並可以此為基礎加入更多進階的功能。","url":"http://tsaith.github.io/zai-rails-shi-zuo-yan-zheng-ji-zhi.html"},{"tags":"Misc","title":"Vim 的常用指令","text":"在編程領域中， 編輯器之戰 的兩位主角 Vi 和 Emacs 經歷幾十年的歲月後， 直到現在依然擁有許多信徒; 而隨著時間的過去，Vi 的功能不斷地被增強，最後演化出目前受歡迎的 Vim ， 關於 Vim 的詳細手冊可查詢 官方文件 ，這裡僅列出常用的一些指令。 環境設定 ~/.vimrc: 環境設定檔 ~/.vim: Vim 專屬的資料夾 內建指令 vi file_name 開啟檔案 Ecs 進入命令模式 :w 存檔 :q 離開 :q! 強制離開(不須先存檔) :e file_name 編輯其它檔案 x 刪除一個字元 i 在游標所在處開始輸入文字 a 從下個字元開始輸入文字 p 將暫存區資料貼上 yy 拷貝游標所在的那一行 3 yy 拷貝連續三行 dd 剪下游標所在的那一行 3 dd 剪下連續三行 D 刪除游標之後的部分 J 連接下一行 :set nu 顯示行數 :set nonu 不顯示行數 ma \"c y 'a 將選擇區段拷貝到 register c \"c p 將 register c 的資料貼上 ma \"+ y 'a 選擇區塊並拷貝到系統的剪貼板 3 \"+ yy 將連續三行到系統的剪貼板 :set ai 自動縮行 :tab_new 新分頁 :ab tn tab_new 將 tab_new 縮寫為 tn :tabprevious 上一個分頁 :tabnext 下一個分頁 map <C-k> :tabprevious <CR> 用 Ctrl + k 映射 :tabpreview map <C-j> :tabnext <CR> 用 Ctrl + j 映射 :tabnext gg 第一行開頭 G 最後一行的開頭 :cd %:h 將工作目錄改變到編輯的檔案下 :lcd %:h 僅將目前視窗的工作目錄改變到編輯的檔案下 autocmd BufEnter * silent! lcd %:p:h 自動改變工作目錄到編輯的檔案下 gf 跳到關聯檔 ( goto file ) Ctrl + &#94; 回到上一個檔案 :!外部命令 執行外部命令，例如 :!ls :syntax enable 語法顏色 視窗分割 :vs 垂直分割 Ctrl + w v 垂直分割 :sp 水平分割 Ctrl + w s 水平分割 Ctrl + w left[right] arrow 左右切換視窗 Ctrl + w up[down] arrow 上下切換視窗 好用的 plugin rails.vim : Rails 套件(語法顏色，快速切換檔案... 等) Rcd 目錄 切換目錄(從專案目錄出發) Rmodel 檔案 編輯 model 檔案 Rview 檔案 編輯 view 檔案 Rcontroller 檔案 編輯 controller 檔案 snipMate : 加入程式片段 Tab 加入程式片段 ctrp : 模糊搜尋 Ctrl + p 啟動模糊搜尋 Ctrl + v 垂直分頁開啟檔案 fencview.vim : 自動偵測多國編碼 :FencAutoDetect 啟動偵測 nerdtree.vim : 檔案瀏覽器 :e . 瀏覽工作目錄 supertab.vmb : 使用 Tab 來補全程式碼 Tab 補全程式碼 雖然 Vim 對初學者而言需要投入多一些的時間來熟悉，但只要上手後， 就會大幅提升你的編程效率。","url":"http://tsaith.github.io/vim-de-chang-yong-zhi-ling.html"},{"tags":"Web","title":"在 Google Chrome 中自定快捷鍵","text":"在開發網站時， 我們常常需要使用 Google Chrome 來協助測試，這裡將介紹如何透過安裝 plugin 來自定快捷鍵，以提高工作效率。 先開啓 Google Chrome ，然後安裝 Shortkeys ; 安裝完成後，即可開始在 Shortkeys 中自定所需的快捷鍵。 設定路徑: Chrome -> Preferences -> Extensions -> Shortkeys -> Options。 設定畫面如下 在這個範例中，分別自定了 command+shift+right 和 command+shift+left 來選擇下一個和上一個瀏覽分頁。","url":"http://tsaith.github.io/zai-google-chrome-zhong-zi-ding-kuai-jie-jian.html"},{"tags":"Web","title":"在部落格中加入 Flickr 圖片","text":"編寫部落格時，適當地加入圖片可以吸引更多讀者，同時也提高了文章的可讀性。 隨著雲端相簿的流行，有許多人會傾向將圖片貯存位置和部落格平台獨立開來; 這樣的話，一方面可以集中圖片的管理，另一方面，如果日後想更換寫作平台， 就不需要去煩惱圖片的轉移工作。 Flickr 是目前相當受歡迎的免費雲端相簿， 這篇文章將說明如何用它將圖片加入到你的部落格中。 首先，請先到 Flickr 上面註冊， 然後在裡面新增一份相簿，接著上傳一張測試圖片並加入到新建立的相簿中。 先選擇圖片，接著點選 \"Share this photo\"，然後指定希望的圖片大小， 這時候會產生對應的 HTML code。 在 HTML code 中 <img src= 後面的部分就是圖片的網址 <img src=\"https://farm8.staticflickr.com/7563/15655510442_e9803f8335_b.jpg\" width=\"1024\" height=\"768\" alt=\"FF-12\"> 最後在你的部落格中使用圖片的網址; 舉例來說， 倘若你使用的是 Octopress ， 請在文章中加入 {% img https://farm8.staticflickr.com/7563/15655510442_e9803f8335_b.jpg %} 然後就能看到被加入的圖片，如下","url":"http://tsaith.github.io/zai-bu-luo-ge-zhong-jia-ru-flickr-tu-pian.html"},{"tags":"Web","title":"在 Rails 中設定多對多關聯性","text":"這裡將介紹如何在 Rails 中透過 has_many through: 來設定多對多關聯性。 而一對多關聯性的介紹可參考先前的 文章 。 假設我們有兩種模型 Post 和 Category， 倘若每個 post 可擁有多個 categories， 而每個 Category 也可以擁有多個 posts， 於是 Post 和 Category 之間就存在著多對多的關係; 以下將敘述如何實作這樣的關聯性。 建立 tables 首先我們需要在資料庫中新增三個 tables， 分別是 posts、categories 和 post_categories; 在 post_categories 中應包含 post_id 和 category_id 這兩個 column。 (如果不清楚如何新增 table 可參考 這裡 ) 新增完 tables 後，請檢查 db/schema.rb 以確定 table 的格式的確如你所預期的 ActiveRecord :: Schema . define ( version : 20141031042824 ) do create_table \"posts\" , force : true do | t | t . string \"title\" t . string \"url\" t . text \"description\" t . datetime \"created_at\" t . datetime \"updated_at\" end create_table \"categories\" , force : true do | t | t . string \"name\" t . datetime \"created_at\" t . datetime \"updated_at\" end create_table \"post_categories\" , force : true do | t | t . integer \"post_id\" t . integer \"category_id\" t . datetime \"created_at\" t . datetime \"updated_at\" end end 設定 models 最後，我們需要指定 Post 和 Category 以及 PostCategory 三個模型之間的關係。 編輯 app/models/post.rb，如下 class Post < ActiveRecord :: Base has_many :post_categories has_many :categories , through : :post_categories end 編輯 app/models/category.rb，如下 class Category < ActiveRecord :: Base has_many :post_categories has_many :posts , through : :post_categories end 編輯 app/models/post_category.rb，如下 class PostCategory < ActiveRecord :: Base belongs_to :post belongs_to :category end 以上，就是在 Rails 中多對多關聯性的實作步驟。","url":"http://tsaith.github.io/zai-rails-zhong-she-ding-duo-dui-duo-guan-lian-xing.html"},{"tags":"Web","title":"在 Rails 中設定 routes","text":"在 Rails 中，當伺服器接受到 http request 時將會根據路由中的設定， 來決定這個 request 將會送往 controller 的哪個 action 進行處理; 這裡將介紹如何設定路由的路徑表。 在 config/routes.rb 可使用 root to: 來設定當使用者存取網站根目錄時的伺服器將會將 request 導向哪裡;假設我們設定如下 PostitTemplate :: Application . routes . draw do root to : 'posts#index' end 接著使用 bundle exec rake routes 來查詢路徑表 $ bundle exec rake routes Prefix Verb URI Pattern Controller#Action root GET / posts#index 在上面的範例中，當 http verb 為 GET 而存取路徑是 / 時，伺服器會將 request 導向 posts controller 的 index action。 倘若我們有個物件模型 Post，這時可以使用 resources 簡潔地來設定對這類物件的一些常用存取路徑 PostitTemplate :: Application . routes . draw do resources :posts end 這時候的路徑表為 $ bundle exec rake routes Prefix Verb URI Pattern Controller#Action posts GET /posts ( .:format ) posts#index POST /posts ( .:format ) posts#create new_post GET /posts/new ( .:format ) posts#new edit_post GET /posts/:id/edit ( .:format ) posts#edit post GET /posts/:id ( .:format ) posts#show PATCH /posts/:id ( .:format ) posts#update PUT /posts/:id ( .:format ) posts#update DELETE /posts/:id ( .:format ) posts#destroy 如果我們只想使用其中幾個路徑，可以用 only: 來達成 PostitTemplate :: Application . routes . draw do resources :posts , only : [ :new , :create ] end 上面只允許加入 new 和 create 兩個對應的路徑 $ bundle exec rake routes Prefix Verb URI Pattern Controller#Action posts POST /posts ( .:format ) posts#create new_post GET /posts/new ( .:format ) posts#new 如果要排除一些路徑，則使用 except: PostitTemplate :: Application . routes . draw do resources :posts , except : [ :new , :create ] end 這時將加入除了 new 和 create 之外的其他路徑 $ bundle exec rake routes Prefix Verb URI Pattern Controller#Action posts GET /posts ( .:format ) posts#index edit_post GET /posts/:id/edit ( .:format ) posts#edit post GET /posts/:id ( .:format ) posts#show PATCH /posts/:id ( .:format ) posts#update PUT /posts/:id ( .:format ) posts#update DELETE /posts/:id ( .:format ) posts#destroy 倘若需要多層的路徑組合，例如每個 post 下面可以 create comment， 這時候可以寫成 PostitTemplate :: Application . routes . draw do resources :posts do resources :comments , only : [ :create ] end end 這樣一來，路徑表就會新增一個 comments controller 的 create action 對應的路徑 $ bundle exec rake routes Prefix Verb URI Pattern Controller#Action post_comments POST /posts/:post_id/comments ( .:format ) comments#create posts GET /posts ( .:format ) posts#index POST /posts ( .:format ) posts#create new_post GET /posts/new ( .:format ) posts#new edit_post GET /posts/:id/edit ( .:format ) posts#edit post GET /posts/:id ( .:format ) posts#show PATCH /posts/:id ( .:format ) posts#update PUT /posts/:id ( .:format ) posts#update DELETE /posts/:id ( .:format ) posts#destroy {% blockquote Rick Cook %} Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to build bigger and better idiots. So far, the universe is winning.","url":"http://tsaith.github.io/zai-rails-zhong-she-ding-routes.html"},{"tags":"Web","title":"在 Rails 中設定一對多關聯性","text":"物件與物件之間的關係,可以是一對一、一對多或多對多; 這裡將介紹如何在 Rails 中設定一對多關聯性。 假設我們現在想設計一個網站讓使用者可以在上面發表文章， 由於每位使用者可以發表多篇文章， 於是使用者和文章之間就存在著一對多的關係; 以下將敘述如何實作這樣的關聯性。 建立 migration 首先， 為 users table 建立 migration 檔案 rails generate migration create_users 執行命令後，將產生對應的檔案(數字部分代表建立的時間) db/migrate/20141028055510_create_users.rb 編輯此檔案的內容，指定 table 包含一個 username 的 column，如下 class CreateUsers < ActiveRecord :: Migration def change create_table :users do | t | t . string :username t . timestamps end end end 然後執行 bundle exec rake db:migrate 這時候資料庫就會產生 users 這個 table。 接下來使用類似步驟來產生 posts table; 先執行 rails generate migration create_posts 然後編輯 db/migrate/20141028043352_create_posts.rb 指定 table 擁有 title 和 user_id 兩個 column class CreatePosts < ActiveRecord :: Migration def change create_table :posts do | t | t . string :title t . integer :user_id t . timestamps end end end 最後，執行 bundle exec rake db:migrate 來產生 posts table。 檢查 database schema 我們可以在專案目錄下查看 db/schema.rb 的內容, 如下 ActiveRecord :: Schema . define ( version : 20141028103914 ) do create_table \"users\" , force : true do | t | t . string \"username\" t . datetime \"created_at\" t . datetime \"updated_at\" end create_table \"posts\" , force : true do | t | t . string \"title\" t . integer \"user_id\" t . datetime \"created_at\" t . datetime \"updated_at\" end end 這裡面記錄了資料庫中 users 和 posts 兩個 tables 分別具有哪些 columns。 設定 models 現在，我們要指定 User model 和 Post model 之間的關係。 首先，新增並編輯 app/models/user.rb，指定 user 可以擁有多個 posts class User < ActiveRecord :: Base has_many :posts end 然後，新增並編輯 app/models/post.rb，指定 post 屬於 user class Post < ActiveRecord :: Base belongs_to :user end 倘若一切順利，現在你已經完成 User 和 Post 一對多的關聯性實作。","url":"http://tsaith.github.io/zai-rails-zhong-she-ding-yi-dui-duo-guan-lian-xing.html"},{"tags":"Misc","title":"Homebrew: Mac 專屬的套件管理者","text":"每一位軟體開發者肯定都需要安裝許多套件來打造所需的開發環境， 而各種套件的版本和相依性一直以來都是件讓人頭痛的問題; 為了讓 Mac 使用者不再總是為此煩惱， 於是有了 Homebrew 的產生。 安裝方式 使用 ruby and curl 進行安裝 ruby -e \"$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)\" 然後接著執行 brew doctor 來檢查系統是否一切正常 brew doctor 如果一切順利，我們就可以開始使用 Homebrew 來進行之後的套件管理。 基本使用方法 如果要搜尋套件，請執行 brew search 套件的部分名稱 若想查詢套件資訊，則執行 brew info 套件名稱 使用 install 來安裝套件 brew install 套件名稱 使用 uninstall 來移除套件 brew uninstall 套件名稱 倘若想更新 Homebrew，請執行 brew update 如果需要更多相關資訊，可以參考 這裡 。","url":"http://tsaith.github.io/homebrew-mac-zhuan-shu-de-tao-jian-guan-li-zhe.html"},{"tags":"Web","title":"一套免費的 SQLite 資料庫瀏覽器","text":"在軟體開發時，我們有時會使用輕量的 SQLite 資料庫來做測試; 這裡要介紹一套好用又免費的工具 DB Browser for SQLite ， 它可以用來幫助使用者方便地建立資料庫和搜尋或編輯其中的資訊。 安裝方式 打開終端機，使用 Homebrew 來進行安裝 brew install sqlitebrowser 使用方法 在命令列直接執行 sqlitebrowser 來啟動 SQLite Brower sqlitebrowser 在界面的工具列點選 Open Database ，然後選擇 SQLite 資料庫所在的位置， 就能開始存取裡面的資訊","url":"http://tsaith.github.io/yi-tao-mian-fei-de-sqlite-zi-liao-ku-liu-lan-qi.html"},{"tags":"Web","title":"使用 Guard::LiveReload 自動刷新瀏覽器","text":"在編寫網頁的過程中，如果每次修改程式後總是需要手動刷新網頁來檢查結果， 實在是件很麻煩又浪費時間的事; 為了解決這問題，於是有人開發了 LiveReload 這工具，每當程式存檔後，網頁就會自動刷新，於是工程師們可以早點收工回家打電動了(誤)。 套件安裝 假設你使用的是 bundler 來管理套件， 首先將 guard 和 guard-livereload 加到 Gemfile 中 group : development do gem 'guard' gem 'guard-livereload' end 接著執行 bundle 開始安裝套件 bundle 然後，初始化一個新的 Guardfile bundle exec guard init 這個檔案記錄了哪些檔案會被監控，可依自己的需求再進行修改 # A sample Guardfile # More info at https://github.com/guard/guard#readme #guard 'livereload', port: '4000' do guard 'livereload' do watch ( %r{app/views/.+\\.(erb|haml|slim)$} ) watch ( %r{app/helpers/.+\\.rb} ) watch ( %r{public/.+\\.(css|js|html)} ) watch ( %r{config/locales/.+\\.yml} ) # Rails Assets Pipeline watch ( %r{(app|vendor)(/assets/\\w+/(.+\\.(css|js|html|png|jpg))).*} ) { | m | \"/assets/ #{ m [ 3 ] } \" } end 另外，瀏覽器也需要安裝對應套件，假設我們使用的是 Google Chrome， 那麼就需要安裝 Chrome LiveReload Extension 。 使用方法 在專案目錄下，執行 bundle exec guard 如果想看到額外的偵錯資訊，則執行 bundle exec guard --debug 最後，點選 Google Chrome 瀏覽器的工具列上的 LiveReload 的圖示， 然後 Chrome 將會與 Guard::LiveReload 作連結。 如果一切順利，現在你每次將程式存檔後，就會看到瀏覽器的頁面自動刷新。","url":"http://tsaith.github.io/shi-yong-guardlivereload-zi-dong-shua-xin-liu-lan-qi.html"},{"tags":"Web","title":"安裝和使用 Git","text":"在軟體開發中過程中，版本控制無疑是相當重要的一環; 而 Git 由於它的優良設計和開源已被廣泛地使用， 這裡將介紹如何在 Mac 上安裝 Git 和基本的使用方法。 套件安裝 在 Mac 上我們可以利用 Homebrew 來 安裝 Git 套件 brew install git 安裝成功後，接下來設定使用者的姓名和郵件位址 git config --global user.name \"Your Name\" git config --global user.email \"user@gmail.com\" 也許你會希望加入顏色支援 git config --global color.ui true 使用方法 進入你的專案目錄後，我們需要先初始化環境 git init 然後會產生 .git/ 資料夾，它儲存著版本控制的各種相關檔案。 如果你有一個 GitHup repository ，並想將它作為遠端儲存 (假設你的帳號是 silver， repository 名稱是 repo); 那麼請執行 git remote add origin https://github.com/silver/repo.git 若想將專案目錄下的所有檔案加入版本控制系統，請執行 git add -A 倘若你只想加入單一檔案，可執行 git add [ File Name ] 若是想加入當前目錄下所有 .txt 結尾的檔案則執行 git add *.txt 若是想刪除當前目錄下的某一個檔案則執行 git rm [ File Name ] 若是想刪除當前目錄下所有 .txt 結尾的檔案則執行 git rm *.txt 在 新增/刪除/修改 檔案後，使用 commit 提交，-m 之後是提交訊息 git commit -m \"Add test.txt\" 倘若你使用的是遠端 repository， 那麼還需要將資料 push 出去 git push -u origin --all 若想查詢目前的控制系統的狀態，請執行 git status 如果想查詢歷史記錄，則使用 log git log 若想查詢某一命令的說明可利用 help ，例如 git help log 倘若有些檔案你不想加入版本控制系統， 可以在專案目錄下新增一個檔案 .gitignore 並將那些檔案記錄下來; 例如，假設你不想記錄那些 .tmp 和 .swp 結尾的檔案， 那麼 .gitignore 的內容為 *.tmp *.swp 若想比較目前和上次 commit 版本的整體差異 git diff HEAD 若只想比較單一檔案在目前和上次 commit 的差別 git diff HEAD&#94; HEAD [Path / File] 若想回復到前一次的 commitment git reset --hard Head&#94; 以上是一些 Git 的基本用法，如果需要更多進階的操作， 請參考 官方文件 。","url":"http://tsaith.github.io/an-zhuang-he-shi-yong-git.html"},{"tags":"Web","title":"產生 SSH Key","text":"在 web 開發中，許多平台 (例如 GitHup, Heroku, AWS ...等) 都使用 SSH Key 來提供安全認證機制; 這裡將說明如何產生 SSH Key。 產生 SSH key 在終端機的命令列，我們可以利用 ssh-keygen 來產生 private key 和 對應的 public key ; 其預設檔名分別是 id_rsa 和 id_rsa.pub， 而預設的儲存路徑為使用者目錄下的 .ssh/ 資料夾。 執行過程中，會詢問是否要設定密碼? (為了安全性的考量，建議設定) ssh-keygen -t rsa -C \"your_email@example.com\" 使用 ssh-agent 如果在產生 SSH key 的過程中，有設定密碼的話， 你會發現每次登入遠端都要重新輸入密碼，相當麻煩; 不過，我們可以使用 ssh-agent 來解決這問題。 假設你的 private key 是 ~/.ssh/id_rsa，這時我們在命令列執行 ssh-add ~/.ssh/id_rsa 然後程式會詢問你的密碼，並儲存下來，之後每次登入就不再需要另外輸入密碼了。","url":"http://tsaith.github.io/chan-sheng-ssh-key.html"},{"tags":"Web","title":"對 Octopress 進行客製化","text":"會選擇使用 Octopress 的使用者， 應該都是希望之後能夠修改自己的部落格， 可以增加需要的功能以及讓版面顯得與眾不同; 這篇文章將會介紹如何進行。 設定部落格標題 在 _config.yml 裡面可以設定部落格的標題和子標題，如下 url : http://tsaith.github.io title : TH's Notes subtitle : Ruby / Rails / Life author : TH simple_search : https://www.google.com/search description : 加入 About 頁面 在 source/_includes/custom/navigation.html 裡面加入 About 連結，如下 <ul class= \"main-navigation\" > <li><a href= \"{{ root_url }}/\" > Blog </a></li> <li><a href= \"{{ root_url }}/blog/archives\" > Archives </a></li> <li><a href= \"{{ root_url }}/about\" > About </a></li> </ul> 執行 rake new_page['about'] 以產生 source/about/index.markdown ， 在檔案內編寫您的自我介紹，如下 ### About me Say something ... 改變 Color Scheme Octopress 預設採用 dark Solarized highlighting， 如果想改用 light style， 可在 sass/custom/_colors.scss 中 uncomment //$solarized: light; ，如下 /* To use the light Solarized highlighting theme uncomment the following line */ $ solarized : light ; 如果需要更多進階設定，請參考 官方文件 。 搜尋功能 在檔案 source/_includes/navigation.html 裡面，將 <input type=\"hidden\" name=\"q\" value=\"site: {{ site.url | shorthand_url }} \" /> 修改為 <input type=\"hidden\" name=\"sitesearch\" value=\" {{ site.url | shorthand_url }} \" /> 然後存檔，即可透過 Google 進行關鍵字搜尋。 留言功能 倘若想開啟 Disqus 留言功能，請進行下面兩個步驟: 到官網 註冊 ，登入後， 選擇 'Add Disqus to your site'，註冊你網站來得到對應的 \"shortname\"。 在 Octopress 專案下，編輯檔案 _config.yml， 在 disqus_short_name: 這一欄填入剛剛取得的 \"shortname\"。 連結內部文章 編輯文章時，常常會需要連結到之前的文章作為參考， 假設欲連結的文章檔名是 2014-10-22-install-rails-on-mac.markdown，那麼可以使用下列的語法 [ link name ]({ % post_url 2014 - 10 - 22 - install - rails - on - mac % }) 倘若上面的語法出現語法解析錯誤，則可以嘗試使用 [ link name ]( / blog / 2014 / 10 / 22 / install - rails - on - mac )","url":"http://tsaith.github.io/dui-octopress-jin-xing-ke-zhi-hua.html"},{"tags":"Web","title":"在 Octopress 使用 Whitespace theme","text":"Whitespace 為你的部落格提供簡約的外觀並將文章置中，此外，它同樣支援響應式設計。 Install $ cd octopress $ git clone git://github.com/lucaslew/whitespace.git .themes/whitespace $ rake install [ 'whitespace' ] # for zsh, use: rake install\\['whitespace'\\]","url":"http://tsaith.github.io/zai-octopress-shi-yong-whitespace-theme.html"},{"tags":"Web","title":"使用 Octopress 建構部落格","text":"Octopress 是一套優良的部落格框架， 使用者可依照個人需求，設計專屬版面和擴充新功能，關於使用它的種種好處， 可參考神人xdite的 文章 。 安裝 Octopress 打開終端機，將 Octopress 的 repository 複製一份到本地端，並指定希望的資料夾名稱。 git clone git://github.com/imathis/octopress.git directory_name 進入資料夾，安裝相關套件; bundle install 然後，安裝預設主題， rake install 現在，我們已經完成所有的安裝步驟。 將檔案部署到 GitHup 首先在 GitHup 建立新的 repository，並命名為 [帳號].github.io; 例如，我的帳號是 tsaith，所以對應的名字就是 tsaith.github.io 。 然後使用終端機，在對應的部落格資料夾下執行 rake setup_github_pages setup_github_pages 將會請你輸入 GitHup repository 的 URL 來設定 GitHup pages。 執行下面指令來產生部落格檔案， rake generate 接著 deploy 檔案到 GitHup pages， rake deploy 最後，將 source 也 push 到 GitHub repository。 git add . git commit -m \"你的訊息\" git push origin source 如果一切順利，你現在已經有了自己的部落格，而對應網址是 [使用者帳號].github.io。 新增文章 我們可以使用 new_post 來新增文章，這指令將會在 source/_posts/ 下面產生對應的檔案。 rake new_post[\"article title\"] 就會在 source/_posts/ 下面新增文章的草稿。 若打開每篇文章的內容會看到最上方會有一些設定資訊如下 --- layout: post title: \"在 Mac 上安裝 Rails\" date: 2014-10-22 12:04:25 +0800 comments: true categories: Rails --- 我們將內容編寫於設定資訊的下方，而撰寫格式則是採用 Markdown 語法。 當撰寫文章時，我們可以新開一個終端機視窗並在專案資料夾下執行 rake preview ，然後開啟瀏覽器連到 http://localhost:4000 進行預覽。 rake preview 當編輯完新文章後，執行 rake generate 產生部落格檔案，然後再將它們 deploy 到 GitHup pages; rake generate rake deploy 最後，別忘了 push 對應的 source 到你的 GitHup repository! 連結內部文章 編輯文章時，常常會需要連結到之前的文章作為參考， 假設欲連結的文章檔名是 2014-10-22-install-rails-on-mac.markdown，那麼可以使用下列的語法 [名稱]({% post_url 2014-10-22-install-rails-on-mac %}) 倘若上面的語法出現語法解析錯誤，則可以嘗試使用 [名稱]( /blog/2014/10/22/install-rails-on-mac )","url":"http://tsaith.github.io/shi-yong-octopress-jian-gou-bu-luo-ge.html"},{"tags":"Web","title":"在 Mac 上安裝 Rails","text":"系統環境: OSX 10.9.x 這篇筆記僅記錄了本人安裝 Rails 的步驟，若需要更詳細的說明，請參考 Install Rails 。 首先開啟 App Store 搜尋並安裝 Xcode (下載通常需要等候一段時間) 接著使用終端機安裝 Homebrew ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 然後檢查安裝是否成功 brew doctor 安裝 Git brew install git 設定使用者姓名和郵件地址 git config --global user.name \"你/妳的姓名\" git config --global user.email \"郵件地址\" 安裝 RVM \\curl -sSL https://get.rvm.io | bash 安裝 Ruby (這裡以版本 2.1.1 為範例) rvm install 2.1.1 最後，開始安裝 Rails gem install rails --no-ri --no-rdoc 若以上所有步驟都順利完成，那恭喜你/妳可以開始享受撰寫Rails的樂趣了。","url":"http://tsaith.github.io/zai-mac-shang-an-zhuang-rails.html"}]}